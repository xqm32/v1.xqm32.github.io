[{"content":"一个好的博客往往需要评论区的支撑，但使用自建服务器做评论区显然有点略显奢侈了，而使用 Gitalk 搭建博客评论区显然是一个不错的选择。\n加入 Gitalk 的方法 这里以 PaperMod 主题为例子，理论上也适用于其他主题，具体还请查阅所用主题的相关文档。\n在 PaperMod 主题中，我们只需要在根目录下创建 layouts/partials/comments.html 文件即可（或者复制 themes/PaperMod/layouts/partials/comments.html 至根目录即可）。\n此后，我们可以参照 Gitalk 文档，在 comments.html 加入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;gitalk-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var gitalk = new Gitalk({ clientID: \u0026#39;GitHub Application Client ID\u0026#39;, clientSecret: \u0026#39;GitHub Application Client Secret\u0026#39;, repo: \u0026#39;GitHub repo\u0026#39;, // The repository of store comments,  owner: \u0026#39;GitHub repo owner\u0026#39;, admin: [\u0026#39;GitHub repo owner and collaborators, only these guys can initialize github issues\u0026#39;], id: location.pathname, // Ensure uniqueness and length less than 50  distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render(\u0026#39;gitalk-container\u0026#39;) \u0026lt;/script\u0026gt;   注意：这里的 clientID 等内容请参考文档中 Usage 进行申请。\n此外，还应在 config.yml 中的 params 项下加入 comments: true 以使得评论系统生效。\n","date":"2022-01-09T20:36:22+08:00","permalink":"https://xqm32.org/p/%E4%B8%BA-hugo-%E5%8D%9A%E5%AE%A2%E5%8A%A0%E5%85%A5-gitalk/","title":"为 Hugo 博客加入 Gitalk"},{"content":"此前笔者已经写过一篇配置 WSL - VS Code 开发流配置相关的文章，然而微软给出了更加方便地配置方法，所以这里也给出配置的优化。\n安装 WSL 由于微软的优化，现在我们只需要在 Powershell 中输入：\n1  wsl --install   即可完成 Windows Subsystem for Linux 的安装，此命令会附加安装一个 Ubuntu 发行版，因而亦不需要在 Microsoft Store 中再次下载。\n更换 WSL 的镜像源 国内访问 Ubuntu 的默认软件源速度较慢，因而我们需要更换一个镜像源以加快软件源的访问速度。这里以 USTC 的镜像源为例，只需在 WSL 终端中输入：\n1  sudo sed -i \u0026#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g\u0026#39; /etc/apt/sources.list   即可完成换源。\n更新软件包 在 WSL 终端中输入：\n1 2  sudo apt update sudo apt upgrade   即可更新。\n其他 余下的步骤可以参考笔者之前的文章。\n","date":"2021-11-28T19:15:16+08:00","permalink":"https://xqm32.org/p/wsl-vs-code-%E5%BC%80%E5%8F%91%E6%B5%81%E9%85%8D%E7%BD%AE/","title":"WSL - VS Code 开发流配置"},{"content":"笔者编写此文的本意是为了记录和索引公式。其内容源于笔者经验，不免有所疏漏，还请读者于评论区指出。\n笔者希望记忆方便，故本文主要使用汉字式公式，为确保无歧义，亦附有字母式公式作为参考。\n公式索引 必须掌握的公式将加粗表示，不常用的公式将以灰色表示。\n二层  [侧棱][正面] 左上右下右 逆左顺 - URU\u0026rsquo;R\u0026rsquo;U\u0026rsquo; F\u0026rsquo;UF [侧棱][右面] 下逆上左 下右上顺 - R\u0026rsquo;F\u0026rsquo;RU RU\u0026rsquo;R\u0026rsquo;F  三层  [顶棱][右手] 顺 左上右下 逆 - F URU\u0026rsquo;R\u0026rsquo; F\u0026rsquo; 二前四左：顶面空缺块个数和左下角块朝向。 [顶棱][左手] 逆 右上左下 顺 - F\u0026rsquo; U\u0026rsquo;L\u0026rsquo;UL F [小鱼][右手] 上左下左上左左下 - RUR\u0026rsquo;URU2R\u0026rsquo; 小鱼公式的鱼头应向下。 [小鱼][左手] 上右下右上右右下 - L\u0026rsquo;U\u0026rsquo;LU\u0026rsquo;L\u0026rsquo;U'2L [顶棱][右手] 左左上左左下顺顺 - U2RU2R\u0026rsquo;F2 [顶棱][左手] 左左上左左下顺顺 - U2L\u0026rsquo;U2LF2  汉英对照  左 - U 右 - U' 上 - R / L' 下 - R\u0026rsquo; / L 顺 - F 逆 - F'  参考资料  GAN 魔方的层先法教程 最简单的三阶魔方入门教程  ","date":"2021-11-21T19:51:02+08:00","permalink":"https://xqm32.org/p/%E4%B8%89%E9%98%B6%E9%AD%94%E6%96%B9%E5%B1%82%E5%85%88%E6%B3%95%E8%BF%98%E5%8E%9F%E6%95%99%E7%A8%8B/","title":"三阶魔方层先法还原教程"},{"content":"注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。\n若文中存在任何问题或有任何疑问请在此评论。\n概述   Java 发展历史：\n① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；\n② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。\n  J2ME、J2SE、J2EE：\nJ2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；\nJ2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；\nJ2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。\n  Java 语言的特点：\n开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；\n WORA：Write One, Run Anywhere\n   Java 与 C++ 的比较：\n① Java 无指针；\n② Java 无结构体和联合体；\n③ Java 无运算符重载；\n④ Java 无多重继承，以**接口（interface）**取代；\n⑤ Java 无头文件和预处理；\n⑥ Java 无 goto 关键字；\n⑦ Java 有 GC（Garbage Collection，垃圾回收）；\n  JVM、JRE、JDK 的区别与联系：\nJVM：Java Virtual Machine（Java 虚拟机），是执行 Java 字节码的虚拟机，能够执行编译后 Java 语言编写的程序；\nJRE：Java Runtime Environment（Java 运行时），包含了 JVM，和标准类库（Class Library），用户需要安装 JRE 来运行 Java 程序；\nJDK：Java Development Kit（Java 开发工具包），包含了 JRE，开发者需要安装 JDK 来编译、调试 Java 程序。\n  Java 源代码（.java 文件）由编译器（javac）编译为字节码（.class 文件）再由解释器（java）执行。\n  一份 Java 源代码可以包含多个类的定义，但仅能有一个 public 修饰的类，且文件名须与此类一致。\n A class may be declared with the modifier public, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package (packages are named groups of related classes — you will learn about them in a later lesson.)\n   Java 的编译器：javac，解释器：java。\n  PATH 和 CLASSPATH：\nPATH 中应包含 Java 的编译器、解释器等可执行程序；\nCLASSPATH 中应包含除标准类库外所需的类的路径（包含当前路径 .）。\n  包的定义：package；\n包的导入：import。\n  Java 的语法  标识符的命名：\n一个合法的标识符应当是一个：以 Unicode 字符、$ 字符或 _ 字符开头，由 Unicode 字符和数字组成的，不限长度的，从未被使用过的字符序列。\n注意：一个合法的标识符不应是关键字、保留字（const、goto）或字面量（true、false、null）。\n  Java 的数据类型：\nJava 的原始数据类型（byte、short、int、long、float、double、boolean、char）、Java 的数组、Java 的类、Java 的接口、Java 的枚举类型；\nJava 的原始数据类型使用值传递，Java 的复杂数据类型使用地址传递（* 笔者的理解是因为内存的占用，值传递和地址传递占用的内存大致相同）。\n  Java 中的 char 类型使用 2 字节的 Unicode 编码。\n  Java 中 8 个原始数据类型对应着 8 个类型的封装。\n  Java 中的字符串类：String、StringBuffer；\nString 的典型方法：equals()、indexOf()。\n  Java 中的类型转换：遵循里氏替换原则，精度损失视为错误。\n  Java 中的数组，拥有内置的（built-in）length 属性。\n  Java 控制流中的分支语句：break、continue 可以控制带有标号的控制语句。\n  参考 PPT 中生成随机数数组的例题（* 也可参考 Java Tutorial 中的例子）。\n  面向对象编程  面向对象编程（OOP）的三大特征：继承、封装、多态。\n  类的声明、成员变量的声明、方法的定义。\n  静态成员（类变量、类方法）：\n不被推荐（discouraged）但正确的类方法的调用：instanceName.methodName(args)。\n  构造方法：\n① 与类同名；\n② 无返回值；\n③ 由关键字 new 调用；\n④ 可重载，但每两个重载的构造方法不应当同时有相同数量、相同类型且相同顺序的参数（确保无歧义）；\n⑤ 若未定义构造方法，编译器将默认提供一个无参的构造方法。\n注意：构造方法不是成员。\n A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.\n   访问控制：\n   Modifier Class Package Subclass World     public Y Y Y Y   protected Y Y Y N   no modifier Y Y N N   private Y N N N    （* 没有修饰符表示包内私有（package-private））\n  继承：\n① 除了没有父类的 Object 类，每一个类都有且只有一个父类（单重继承）；\n② Object 类是所有类的隐式（implicitly）父类；\n③ 子类将继承一切父类公有（public）或保护（protected）的成员（包括：属性（fields）、方法（methods）、嵌套类（nested classes））。\n注意：① 构造方法不是成员，故而不被子类继承，但可以被子类调用；② 嵌套类（nested class）可以访问其外部类的所有私有成员，因而子类可以通过其间接访问父类的成员。\n  重载（Overload）与重写（Override）：\n重载：重载的方法具有相同的方法名，不同的参数数量、类型或顺序；\n重写：重写的方法具有相同的方法名、参数的数量、类型和顺序与相同或为其子类的返回类型。\n  关键字 this 和 super：\nthis 关键字：用于区分自身属性和外部参数；\nsuper 关键字：用于重写时区分父类与子类的参数或调用父类的构造方法。\n  方法重写的原则：\n要满足里氏替换原则，因而有 ① 访问权限不应比父类更严格；② 抛出的异常不应比父类更多。\n  多态（polymorphism）：运行时多态、编译时多态。\n The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable\u0026rsquo;s type. This behavior is referred to as virtual method invocation and demonstrates an aspect of the important polymorphism features in the Java language.\n   运行时多态的两个前提：① 上溯造型；② 方法重写。\n  final 关键字：\n修饰变量：不可被修改，为常量；\n修饰方法：不可被重写；\n修饰类：不可被继承。\n  抽象 抽象（abstract 关键字），可以修饰类和方法，也可修饰接口，但那是不必要的（unnecessary）。 抽象类：abstract 关键字修饰的类，不能实例化（* 但不代表不能有一个抽象类型的变量）。 抽象方法：abstract 关键字修饰的方法，没有实现。 抽象类中有任意数量的抽象方法和任意数量的非抽象方法。 非抽象方法可以调用抽象方法（只有 abstract 关键字修饰的类拥有抽象方法）（* 由于实例必然是一个非抽象类，调用的抽象方法将一定被实现）。 非抽象子类应当实现继承的抽象父类的所有抽象方法和抽象父类的未实现的接口（只有 abstract 关键字修饰的类拥有抽象方法）。 抽象类存在的必要性：通过抽象方法规定子类必须完成的方法（动作）。  接口  接口（interface 关键字），只包含常量（constants）和抽象方法（* 实际上还有方法签名（method signatures）、默认方法（default methods））。\n实现（implements 关键字）。\n  接口中的常量无需修饰，默认为 public static final；方法亦无需修饰，默认为 public abstract。\n  一个类可以实现多个接口，接口也可以实现接口。\n  非抽象类应当实现接口的所有方法（* 可以理解为抽象只存在于抽象中，实际上 default 关键字修饰的无需实现）。\n  内部类 注意：内部类（inner class）不是静态嵌套类（static nested class）\n① 内部类不能有 static 修饰的成员（属性、方法）（* 存疑，编译时无问题，但 Java Tutorial 明确说明）。\n As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object\u0026rsquo;s methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.\n ② 内部类可以访问外部类的所有成员。\n系统类  Object 类是所有类的父类（间接父类）。\n  Object 类：\nObject::equals(Object obj)：是否是同一个对象（地址相同）；\nObject::getClass()：获取对象的运行时类；\nObject::toString()：转换为字符串，相当于 getClass().getName() + '@' + Integer.toHexString(hashCode())。\n  String 类：\nString::equals(Object obj)：当且仅当 obj 参数不为 null、类型为 String 且所存储的字符序列相同时返回 true（* 也就是该方法的参数不必须是一个 String）。\nString::length()：返回字符串的长度，这是一个方法，注意与数组的 length 属性 区分。\nString::compareTo(String anotherString)：顺序为字典序；若前置字符均相同，则短字符串排于长字符串之前。\n  原始数据类型与 String 中的转换：\n原始数据类型转换为 String：使用 String.valueOf() 方法 或用加法运算符；\nString 转换为原始数据类型：使用如 Integer.parseInt 式的方法。\n  Vector 列表和 ArrayList 列表：Vector 是**线程安全（thread-safe）**的，但如果线程安全不是必须，更推荐使用 ArrayList。\n  异常处理  异常处理的基本概念，异常处理的优势。\n  JVM 中的运行时错误和 Java 的异常类的对应关系：由 JVM 对应。\n  PPT 中关于异常的图：\n  Java 中的异常类：\n运行时异常（RuntimeException 及其子类，又称 unchecked Exception）：编译器将不会检查异常的捕获情况（* PPT 中认为运行时异常一定是程序的错误）。\n If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.\n   异常的处理方法：\n① try-catch-finally 捕获异常；\n② 使用 throws 关键字，不进行处理。\n  throws 关键字：指定（specify）一个方法可能抛出的所有异常，非运行时异常可以不被指定；\nthrow 关键字：抛出的是一个 Throwable 对象。\n  输入输出流  输入输出流的四个抽象类：\n① InputStream 抽象类：以字节（byte）为单位进行输入；\n② OutputStream 抽象类：以字节（byte）为单位进行输出；\n③ Reader 抽象类：以字符（character）为单位进行输入；\n④ Writer 抽象类：以字符（character）为单位进行输出。\n  能够用字节流、字符流编写文件的拷贝程序。\n字节流：InputStream::read() 到达文件的终止位时将会返回 -1。\n If no byte is available because the end of the stream has been reached, the value -1 is returned.\n   File 类：File::File(String pathname)。\n  InputStreamReader 类、OutputStreamWriter 类。\n  BufferedReader 类、BufferedWriter 类。\n  多线程  继承 Thread 类或实现 Runnable 接口来完成多线程。\n  多线程的四种状态图，参考 PPT（* stop() 已经废弃（Deprecated）了）。\n  编写多线程程序的两种方法：\n① 继承 Thread 类，重写 run() 方法。\n② 实现 Runnable 接口，并通过其构造一个 Thread 类。\n  锁和同步。\n  Thread.sleep(long millis) 方法、Thread.currentThread() 方法。\n  网络编程  URL 类，URL 类的 API：\nURL::openStream 方法：返回一个字节输入流（InputStream）。\n  Socket 类通信，Socket 类的 API，ServerSocket 类的 API。\n  GUI 编程  各类组件。\n  Frame 容器、Panel 容器；\nWindows、Frame 容器的默认布局为 BorderLayout；\nPanel、Applet 容器的默认布局为 FlowLayout。\n  容器的常用方法 add()、setLayout()、setSize()。\n  AWT 事件监听模型，参考 PPT。\n  Button 的消息响应：可以参考 Java Tutorial 中的例子。\n  知识点之外 以下是除了课程老师给的知识点参考之外的知识点\n Lambda 表达式：\n A functional interface is any interface that contains only one abstract method. (A functional interface may contain one or more default methods or static methods.) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it.\n 语法：() -\u0026gt; {}（* 亦可使用简写）；\n  InputStream 字节输入流、OutputStream 字节输出流的一些方法：\nInputStream::readAllBytes()：读取所有的字节，返回一个字节数组；\nOutputStream::write(byte [])：写入字节数组。\n  IOException 是非运行时异常，必须被捕获。\n  参考资料  Java SE 参考资料 — 白皮书； Java SE 17 \u0026amp; JDK 17 API Specification； The Java Tutorials。  ","date":"2021-11-14T17:34:20+08:00","permalink":"https://xqm32.org/p/java-%E8%AF%BE%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","title":"Java 课程知识点总结"},{"content":"此文章已经过时，请参考微软给出的更新的教程 安装 WSL\n本教程基于 在 Windows 10 上安装 WSL 和 开始使用 WSL VS Code 编写，笔者不保证内容的准确性。如有任何疑问，请参考微软有关 WSL 的官方文档。\n启用 WSL（适用于 Linux 的 Windows 子系统） 以管理员身份打开 Powershell（可以右击 Windows 徽标键，并选择该项）并运行如下命令：\n1  dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart   如果想要更新到 WSL 2 请转到 更新至 WSL 2 。若希望直接使用 WSL 1 请直接 重新启动 并转到 安装并配置 Linux 发行版。\n更新至 WSL 2 注意：若要更新至 WSL 2，请确保 Windows 10 已经达到以下运行要求：\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。 低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手 更新 Windows 版本。  启用虚拟机功能 以管理员身份打开 Powershell 并运行如下命令：\n1  dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart   重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\nWSL 2 的后续步骤 请参考 后续步骤 来完成，后转 安装并配置 Linux 发行版。\n安装并配置 Linux 发行版 打开 Microsoft Store，安装一个 Linux 发行版，并打开此发行版，后按照提示进行操作即可。\n对于 Linux 的相关操作，请自行搜索。\n更改 WSL 的镜像源 使用默认的源下载软件是较为缓慢的，因而我们需要更换更快速的镜像。在国内，我们常用的是 清华大学 和 中国科学技术大学 的镜像。请确认 WSL 的发行版，根据需求选择要使用的镜像：\n 清华大学开源软件镜像站 USTC Open Source Software Mirror  在 WSL 上安装 C/C++ 的编译器 以 Ubuntu 为例，使用如下命令安装：\n1  sudo apt-get install gcc g++   注意：在安装之前，可能需要进行包的更新，可使用如下命令更新：\n1 2  sudo apt-get update sudo apt-get upgrade   对于其他 Linux 发行版，请自行在网络上搜索安装与更新的命令，这里不再赘述。\n将 WSL 与 VS Code 一并使用 以下内容参考 开始使用 WSL VS Code，笔者不确保内容的准确性。如有疑问请参考原文。\n安装并配置 VS Code 访问 VS Code 安装页 选择适合的安装程序。\n打开 VS Code，点击拓展并搜索 「WSL」，安装 WSL 远程拓展包，即可完成操作。在中文环境下，我们还可以安装 VS Code 推荐的中文语言包，以方便阅读。\n对于 C/C++，我们可以在拓展中搜索 C++，以安装其有关拓展（包含了语法高亮、调试等功能）。\n更多的 WSL 与 VS Code 共同使用的小技巧的注意事项，请参考 开始使用 WSL VS Code\n使用 WSL 和 VS Code 编写 Hello world! 程序 注意：以下仅为简单的、单文件的 C 语言编写的源文件的编译方法，笔者不保证（实际上是几乎不能）适用于生产环境。若要了解一种生产环境下的 C 语言编译方法，请参考 CMake。\n首先，需要进入存放源代码的文件夹，请读者自行建立，或在 Home 文件夹直接进行。\n运行如下命令，创建 main.c 源文件（提示：在 Linux 下键入命令时，请善用 Tab 键自动补全）：\n1  touch main.c   在 VS Code 中，点击左下角打开远程窗口按钮，选择 New WSL Window 即可连接至 WSL。打开存放 main.c 的文件夹，使用 VS Code 编辑 main.c 文件，填入如下内容：\n1 2 3 4 5  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello world!\\n\u0026#34;); }   按下 ctrl + ` 打开命令行终端，输入以下命令编译此程序：\n1  gcc main.c   此时，输入 ls 命令，我们可以看到当前目录下已经生成了一个名为 a.out 的可执行文件。\n我们执行这个程序（注意：./ 是不可缺少的，具体原因请自行搜索，这里不再赘述）：\n1  ./a.out   可以看到输出：\n1  Hello world!   若要重新编译源文件，请使用 rm 命令，删除 a.out 文件，并再次执行编译命令。\n若要了解其他 gcc 命令的使用方法，请执行命令 man gcc 或 gcc --help。更多 Linux 常用命令请自行于网络上搜索。\n","date":"2021-09-13T19:03:23+08:00","permalink":"https://xqm32.org/p/%E4%BD%BF%E7%94%A8-wsl-%E5%92%8C-vs-code-%E9%85%8D%E7%BD%AE-c/c-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","title":"使用 WSL 和 VS Code 配置 C/C++ 开发环境"},{"content":"搬运一篇笔者在知乎发的文章：C 语言实现字符串切片\n基于 Python 的切片的格式实现的 C 语言字符串切片：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include \u0026lt;ctype.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef long long SizeType; size_t fgetln(FILE* stream, char* dest, size_t size) { size_t i; for (i = 0, *dest = fgetc(stream); *dest != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; !feof(stream) \u0026amp;\u0026amp; --size \u0026gt; 0; ++i, *++dest = fgetc(stream)) ; *dest = \u0026#39;\\0\u0026#39;; return i; } // 读取一行字符串。  size_t slice(char* from, char* to, SizeType begin, SizeType end, SizeType interval) { SizeType i; begin += begin \u0026lt; 0 ? strlen(from) : 0; end += end \u0026gt; 0 ? 0 : strlen(from); interval = interval ? interval : 1; for (i = 0; from[begin] != \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; begin \u0026lt; end; ++i, begin += interval) to[i] = from[begin]; to[i] = \u0026#39;\\0\u0026#39;; return i; } // 切片函数。  char* StrSize(char* from, SizeType* m, SizeType* n, SizeType* o) { *m = atoll(from); from = strchr(from, \u0026#39;:\u0026#39;); if (!from) return from; *n = atoll(++from); from = strchr(from, \u0026#39;:\u0026#39;); if (!from) return from; *o = atoll(++from); return from; } // 字符串解析成数字，由 \u0026#34;:\u0026#34; 分隔。  size_t strslice(char* format, char* from, char* to) { SizeType m = 0, n = 0, o = 0; StrSize(format, \u0026amp;m, \u0026amp;n, \u0026amp;o); // printf(\u0026#34;%lld, %lld, %lld\\n\u0026#34;, m, n, o);  return slice(from, to, m, n, o); } // 用字符串作为切片的格式的切片函数。  int main(int argc, char* argv[]) { char* String = malloc(128); char* Format = malloc(128); char* Save = malloc(128); for (;;) { memset(String, 0, 128); memset(Format, 0, 128); memset(Save, 0, 128); fgetln(stdin, String, 128); fgetln(stdin, Format, 128); strslice(Format, String, Save); printf(\u0026#34;%s\\n\u0026#34;, Save); } }   测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  Hello world :: Hello world Hello world 1 ello world Hello world -1 d Hello world 1: ello world Hello world -1: d Hello world :1 H Hello world :-1 Hello worl Hello world ::1 Hello world Hello world ::2 Hlowrd Hello world 1:-1 ello worl Hello world 2:1 [无输出] Hello world -2:-1 l Hello world -1:-2 [无输出]   ","date":"2021-09-04T16:33:50+08:00","permalink":"https://xqm32.org/p/c-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87/","title":"C 语言实现字符串切片"},{"content":"笔者一直想有个属于自己的博客，通过在网上不断搜索，笔者发现使用 Hugo 部署至 Github Pages 上是一个不错的选择。但是，这样的部署也有一个缺陷：需要手动生成部署文件，再上传至 Github，这是十分麻烦的。因此笔者又在网上搜索文档、文章，后来了解到，可以使用 Github Actions 进行自动化部署，我们只需要将网站源码推送至 Github 便可以自动化地生成博客网站。不过，虽然在操作上是方便了许多，但如何配置这样的自动化部署似乎依旧是一个复杂的问题。于是笔者继续在网上搜索文档和文章，但大部分都没有给出较为「官方」的解决方案，也很少有参考资料可供加深了解，故而笔者转向寻求 Hugo 文档 的帮助，最终做到了使用 Github Actions 自动化部署 Hugo 博客。\n准备工作 首先，我们需要创建可以用于部署 Hugo 博客的 Github 仓库，具体的操作可以参考 GitHub Pages 文档 。\n其次，我们需要在电脑上安装 Git 和 Hugo（注意：在 Linux，特别是 Ubuntu 上，请不要使用默认的包管理器安装 Hugo，此法安装的 Hugo 版本有时过低，会造成大量错误），请参考 此文档 进行安装。\n之后，我们将使用 Hugo 在本地创建网站，名称建议使用 username.github.io（其中 username 是你的 Github ID），具体的方法请参照 此文档。\nGithub Actions 在完成准备工作后，我们需要在本地创建网站的文件夹中建立 .github/workflows/gh-pages.yml 文件，在其中填入（此代码参考 Hugo 文档中 Host on GitHub 一项）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  name:github pageson:push:branches:- main # Set a branch to deploypull_request:jobs:deploy:runs-on:ubuntu-20.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;# extended: true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3if:github.ref == \u0026#39;refs/heads/main\u0026#39;with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public  之后推送至 Github，并将仓库中 Settings - Pages - Source - Branch 的设置从 main 修改至 gh-pages 并点击 Save 按钮，即可完成 Github Actions 部署工作。\n","date":"2021-09-04T15:47:24+08:00","permalink":"https://xqm32.org/p/%E4%BD%BF%E7%94%A8-github-actions-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-hugo-%E5%8D%9A%E5%AE%A2/","title":"使用 Github Actions 自动化部署 Hugo 博客"}]