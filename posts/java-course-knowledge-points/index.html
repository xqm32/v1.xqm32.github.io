<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Java 课程知识点总结 | Qiming's Blog</title>
<meta name=keywords content="Java,HFUT,课程">
<meta name=description content="注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。
若文中存在任何问题或有任何疑问请前往 Issue 页面。
概述   Java 发展历史：
① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；
② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。
  J2ME、J2SE、J2EE：
J2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；
J2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；
J2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。
  Java 语言的特点：
开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；
 WORA：Write One, Run Anywhere
   Java 与 C++ 的比较：
① Java 无指针；
② Java 无结构体和联合体；
③ Java 无运算符重载；">
<meta name=author content="Qiming Xu">
<link rel=canonical href=https://xqm32.github.io/posts/java-course-knowledge-points/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xqm32.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://xqm32.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://xqm32.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://xqm32.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://xqm32.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Java 课程知识点总结">
<meta property="og:description" content="注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。
若文中存在任何问题或有任何疑问请前往 Issue 页面。
概述   Java 发展历史：
① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；
② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。
  J2ME、J2SE、J2EE：
J2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；
J2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；
J2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。
  Java 语言的特点：
开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；
 WORA：Write One, Run Anywhere
   Java 与 C++ 的比较：
① Java 无指针；
② Java 无结构体和联合体；
③ Java 无运算符重载；">
<meta property="og:type" content="article">
<meta property="og:url" content="https://xqm32.github.io/posts/java-course-knowledge-points/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-14T17:34:20+08:00">
<meta property="article:modified_time" content="2021-11-15T13:15:31+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Java 课程知识点总结">
<meta name=twitter:description content="注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。
若文中存在任何问题或有任何疑问请前往 Issue 页面。
概述   Java 发展历史：
① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；
② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。
  J2ME、J2SE、J2EE：
J2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；
J2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；
J2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。
  Java 语言的特点：
开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；
 WORA：Write One, Run Anywhere
   Java 与 C++ 的比较：
① Java 无指针；
② Java 无结构体和联合体；
③ Java 无运算符重载；">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://xqm32.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java 课程知识点总结","item":"https://xqm32.github.io/posts/java-course-knowledge-points/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java 课程知识点总结","name":"Java 课程知识点总结","description":"注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。\n若文中存在任何问题或有任何疑问请前往 Issue 页面。\n概述   Java 发展历史：\n① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；\n② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。\n  J2ME、J2SE、J2EE：\nJ2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；\nJ2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；\nJ2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。\n  Java 语言的特点：\n开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；\n WORA：Write One, Run Anywhere\n   Java 与 C++ 的比较：\n① Java 无指针；\n② Java 无结构体和联合体；\n③ Java 无运算符重载；","keywords":["Java","HFUT","课程"],"articleBody":"注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。\n若文中存在任何问题或有任何疑问请前往 Issue 页面。\n概述   Java 发展历史：\n① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；\n② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。\n  J2ME、J2SE、J2EE：\nJ2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；\nJ2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；\nJ2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。\n  Java 语言的特点：\n开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；\n WORA：Write One, Run Anywhere\n   Java 与 C++ 的比较：\n① Java 无指针；\n② Java 无结构体和联合体；\n③ Java 无运算符重载；\n④ Java 无多重继承，以**接口（interface）**取代；\n⑤ Java 无头文件和预处理；\n⑥ Java 无 goto 关键字；\n⑦ Java 有 GC（Garbage Collection，垃圾回收）；\n  JVM、JRE、JDK 的区别与联系：\nJVM：Java Virtual Machine（Java 虚拟机），是执行 Java 字节码的虚拟机，能够执行编译后 Java 语言编写的程序；\nJRE：Java Runtime Environment（Java 运行时），包含了 JVM，和标准类库（Class Library），用户需要安装 JRE 来运行 Java 程序；\nJDK：Java Development Kit（Java 开发工具包），包含了 JRE，开发者需要安装 JDK 来编译、调试 Java 程序。\n  Java 源代码（.java 文件）由编译器（javac）编译为字节码（.class 文件）再由解释器（java）执行。\n  一份 Java 源代码可以包含多个类的定义，但仅能有一个 public 修饰的类，且文件名须与此类一致。\n A class may be declared with the modifier public, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package (packages are named groups of related classes — you will learn about them in a later lesson.)\n   Java 的编译器：javac，解释器：java。\n  PATH 和 CLASSPATH：\nPATH 中应包含 Java 的编译器、解释器等可执行程序；\nCLASSPATH 中应包含除标准类库外所需的类的路径（包含当前路径 .）。\n  包的定义：package；\n包的导入：import。\n  Java 的语法  标识符的命名：\n一个合法的标识符应当是一个：以 Unicode 字符、$ 字符或 _ 字符开头，由 Unicode 字符和数字组成的，不限长度的，从未被使用过的字符序列。\n注意：一个合法的标识符不应是关键字、保留字（const、goto）或字面量（true、false、null）。\n  Java 的数据类型：\nJava 的原始数据类型（byte、short、int、long、float、double、boolean、char）、Java 的数组、Java 的类、Java 的接口、Java 的枚举类型；\nJava 的原始数据类型使用值传递，Java 的复杂数据类型使用地址传递（* 笔者的理解是因为内存的占用，值传递和地址传递占用的内存大致相同）。\n  Java 中的 char 类型使用 2 字节的 Unicode 编码。\n  Java 中 8 个原始数据类型对应着 8 个类型的封装。\n  Java 中的字符串类：String、StringBuffer；\nString 的典型方法：equals()、indexOf()。\n  Java 中的类型转换：遵循里氏替换原则，精度损失视为错误。\n  Java 中的数组，拥有内置的（built-in）length 属性。\n  Java 控制流中的分支语句：break、continue 可以控制带有标号的控制语句。\n  参考 PPT 中生成随机数数组的例题（* 也可参考 Java Tutorial 中的例子）。\n  面向对象编程  面向对象编程（OOP）的三大特征：继承、封装、多态。\n  类的声明、成员变量的声明、方法的定义。\n  静态成员（类变量、类方法）：\n不被推荐（discouraged）但正确的类方法的调用：instanceName.methodName(args)。\n  构造方法：\n① 与类同名；\n② 无返回值；\n③ 由关键字 new 调用；\n④ 可重载，但每两个重载的构造方法不应当同时有相同数量、相同类型且相同顺序的参数（确保无歧义）；\n⑤ 若未定义构造方法，编译器将默认提供一个无参的构造方法。\n注意：构造方法不是成员。\n A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.\n   访问控制：\n   Modifier Class Package Subclass World     public Y Y Y Y   protected Y Y Y N   no modifier Y Y N N   private Y N N N    （* 没有修饰符表示包内私有（package-private））\n  继承：\n① 除了没有父类的 Object 类，每一个类都有且只有一个父类（单重继承）；\n② Object 类是所有类的隐式（implicitly）父类；\n③ 子类将继承一切父类公有（public）或保护（protected）的成员（包括：属性（fields）、方法（methods）、嵌套类（nested classes））。\n注意：① 构造方法不是成员，故而不被子类继承，但可以被子类调用；② 嵌套类（nested class）可以访问其外部类的所有私有成员，因而子类可以通过其间接访问父类的成员。\n  重载（Overload）与重写（Override）：\n重载：重载的方法具有相同的方法名，不同的参数数量、类型或顺序；\n重写：重写的方法具有相同的方法名、参数的数量、类型和顺序与相同或为其子类的返回类型。\n  关键字 this 和 super：\nthis 关键字：用于区分自身属性和外部参数；\nsuper 关键字：用于重写时区分父类与子类的参数或调用父类的构造方法。\n  方法重写的原则：\n要满足里氏替换原则，因而有 ① 访问权限不应比父类更严格；② 抛出的异常不应比父类更多。\n  多态（polymorphism）：运行时多态、编译时多态。\n The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable’s type. This behavior is referred to as virtual method invocation and demonstrates an aspect of the important polymorphism features in the Java language.\n   运行时多态的两个前提：① 上溯造型；② 方法重写。\n  final 关键字：\n修饰变量：不可被修改，为常量；\n修饰方法：不可被重写；\n修饰类：不可被继承。\n  抽象 抽象（abstract 关键字），可以修饰类和方法，也可修饰接口，但那是不必要的（unnecessary）。 抽象类：abstract 关键字修饰的类，不能实例化（* 但不代表不能有一个抽象类型的变量）。 抽象方法：abstract 关键字修饰的方法，没有实现。 抽象类中有任意数量的抽象方法和任意数量的非抽象方法。 非抽象方法可以调用抽象方法（只有 abstract 关键字修饰的类拥有抽象方法）（* 由于实例必然是一个非抽象类，调用的抽象方法将一定被实现）。 非抽象子类应当实现继承的抽象父类的所有抽象方法和抽象父类的未实现的接口（只有 abstract 关键字修饰的类拥有抽象方法）。 抽象类存在的必要性：通过抽象方法规定子类必须完成的方法（动作）。  接口  接口（interface 关键字），只包含常量（constants）和抽象方法（* 实际上还有方法签名（method signatures）、默认方法（default methods））。\n实现（implements 关键字）。\n  接口中的常量无需修饰，默认为 public static final；方法亦无需修饰，默认为 public abstract。\n  一个类可以实现多个接口，接口也可以实现接口。\n  非抽象类应当实现接口的所有方法（* 可以理解为抽象只存在于抽象中，实际上 default 关键字修饰的无需实现）。\n  内部类 注意：内部类（inner class）不是静态嵌套类（static nested class）\n① 内部类不能有 static 修饰的成员（属性、方法）（* 存疑，编译时无问题，但 Java Tutorial 明确说明）。\n As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object’s methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.\n ② 内部类可以访问外部类的所有成员。\n系统类  Object 类是所有类的父类（间接父类）。\n  Object 类：\nObject::equals(Object obj)：是否是同一个对象（地址相同）；\nObject::getClass()：获取对象的运行时类；\nObject::toString()：转换为字符串，相当于 getClass().getName() + '@' + Integer.toHexString(hashCode())。\n  String 类：\nString::equals(Object obj)：当且仅当 obj 参数不为 null、类型为 String 且所存储的字符序列相同时返回 true（* 也就是该方法的参数不必须是一个 String）。\nString::length()：返回字符串的长度，这是一个方法，注意与数组的 length 属性 区分。\nString::compareTo(String anotherString)：顺序为字典序；若前置字符均相同，则短字符串排于长字符串之前。\n  原始数据类型与 String 中的转换：\n原始数据类型转换为 String：使用 String.valueOf() 方法 或用加法运算符；\nString 转换为原始数据类型：使用如 Integer.parseInt 式的方法。\n  Vector 列表和 ArrayList 列表：Vector 是**线程安全（thread-safe）**的，但如果线程安全不是必须，更推荐使用 ArrayList。\n  异常处理  异常处理的基本概念，异常处理的优势。\n  JVM 中的运行时错误和 Java 的异常类的对应关系：由 JVM 对应。\n  PPT 中关于异常的图：\n  Java 中的异常类：\n运行时异常（RuntimeException 及其子类，又称 unchecked Exception）：编译器将不会检查异常的捕获情况（* PPT 中认为运行时异常一定是程序的错误）。\n If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.\n   异常的处理方法：\n① try-catch-finally 捕获异常；\n② 使用 throws 关键字，不进行处理。\n  throws 关键字：指定（specify）一个方法可能抛出的所有异常，非运行时异常可以不被指定；\nthrow 关键字：抛出的是一个 Throwable 对象。\n  输入输出流  输入输出流的四个抽象类：\n① InputStream 抽象类：以字节（byte）为单位进行输入；\n② OutputStream 抽象类：以字节（byte）为单位进行输出；\n③ Reader 抽象类：以字符（character）为单位进行输入；\n④ Writer 抽象类：以字符（character）为单位进行输出。\n  能够用字节流、字符流编写文件的拷贝程序。\n字节流：InputStream::read() 到达文件的终止位时将会返回 -1。\n If no byte is available because the end of the stream has been reached, the value -1 is returned.\n   File 类：File::File(String pathname)。\n  InputStreamReader 类、OutputStreamWriter 类。\n  BufferedReader 类、BufferedWriter 类。\n  多线程  继承 Thread 类或实现 Runnable 接口来完成多线程。\n  多线程的四种状态图，参考 PPT（* stop() 已经废弃（Deprecated）了）。\n  编写多线程程序的两种方法：\n① 继承 Thread 类，重写 run() 方法。\n② 实现 Runnable 接口，并通过其构造一个 Thread 类。\n  锁和同步。\n  Thread.sleep(long millis) 方法、Thread.currentThread() 方法。\n  网络编程  URL 类，URL 类的 API：\nURL::openStream 方法：返回一个字节输入流（InputStream）。\n  Socket 类通信，Socket 类的 API，ServerSocket 类的 API。\n  GUI 编程  各类组件。\n  Frame 容器、Panel 容器；\nWindows、Frame 容器的默认布局为 BorderLayout；\nPanel、Applet 容器的默认布局为 FlowLayout。\n  容器的常用方法 add()、setLayout()、setSize()。\n  AWT 事件监听模型，参考 PPT。\n  Button 的消息响应：可以参考 Java Tutorial 中的例子。\n  知识点之外 以下是除了课程老师给的知识点参考之外的知识点\n Lambda 表达式：\n A functional interface is any interface that contains only one abstract method. (A functional interface may contain one or more default methods or static methods.) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it.\n 语法：() - {}（* 亦可使用简写）；\n  InputStream 字节输入流、OutputStream 字节输出流的一些方法：\nInputStream::readAllBytes()：读取所有的字节，返回一个字节数组；\nOutputStream::write(byte [])：写入字节数组。\n  IOException 是非运行时异常，必须被捕获。\n  参考资料  Java SE 参考资料 — 白皮书； Java SE 17 \u0026 JDK 17 API Specification； The Java Tutorials。  ","wordCount":"822","inLanguage":"zh","datePublished":"2021-11-14T17:34:20+08:00","dateModified":"2021-11-15T13:15:31+08:00","author":{"@type":"Person","name":"Qiming Xu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xqm32.github.io/posts/java-course-knowledge-points/"},"publisher":{"@type":"Organization","name":"Qiming's Blog","logo":{"@type":"ImageObject","url":"https://xqm32.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://xqm32.github.io/ accesskey=h title="Qiming's Blog (Alt + H)">Qiming's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://xqm32.github.io/about/ title=关于我>
<span>关于我</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/friends/ title=朋友们>
<span>朋友们</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/posts/ title=文章>
<span>文章</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/notes/ title=笔记>
<span>笔记</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/categories/ title=分类>
<span>分类</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/tags/ title=标签>
<span>标签</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/archives/ title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://xqm32.github.io/search/ title="搜索 (Alt + /)" accesskey=/>
<span>搜索</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Java 课程知识点总结
</h1>
<div class=post-meta><span title="2021-11-15 13:15:31 +0800 +0800">2021-11-15 13:15:31</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Qiming Xu
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>目录</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e6%a6%82%e8%bf%b0httpsdocsoraclecomjavasetutorialgetstartedintroindexhtml aria-label=概述><a href=https://docs.oracle.com/javase/tutorial/getStarted/intro/index.html>概述</a></a></li>
<li>
<a href=#java-%e7%9a%84%e8%af%ad%e6%b3%95 aria-label="Java 的语法">Java 的语法</a></li>
<li>
<a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8bhttpsdocsoraclecomjavasetutorialjavaconceptsindexhtml aria-label=面向对象编程><a href=https://docs.oracle.com/javase/tutorial/java/concepts/index.html>面向对象编程</a></a></li>
<li>
<a href=#%e6%8a%bd%e8%b1%a1httpsdocsoraclecomjavasetutorialjavaiandiabstracthtml aria-label=抽象><a href=https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html>抽象</a></a></li>
<li>
<a href=#%e6%8e%a5%e5%8f%a3httpsdocsoraclecomjavasetutorialjavaiandicreateinterfacehtml aria-label=接口><a href=https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html>接口</a></a></li>
<li>
<a href=#%e5%86%85%e9%83%a8%e7%b1%bbhttpsdocsoraclecomjavasetutorialjavajavaoonestedhtml aria-label=内部类><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html>内部类</a></a></li>
<li>
<a href=#%e7%b3%bb%e7%bb%9f%e7%b1%bbhttpsdocsoraclecomjavasetutorialessentialindexhtml aria-label=系统类><a href=https://docs.oracle.com/javase/tutorial/essential/index.html>系统类</a></a></li>
<li>
<a href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86httpsdocsoraclecomjavasetutorialessentialexceptionsindexhtml aria-label=异常处理><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html>异常处理</a></a></li>
<li>
<a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%b5%81httpsdocsoraclecomjavasetutorialessentialioindexhtml aria-label=输入输出流><a href=https://docs.oracle.com/javase/tutorial/essential/io/index.html>输入输出流</a></a></li>
<li>
<a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8bhttpsdocsoraclecomjavasetutorialessentialconcurrencyprocthreadhtml aria-label=多线程><a href=https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html>多线程</a></a></li>
<li>
<a href=#%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8bhttpsdocsoraclecomjavasetutorialnetworkingindexhtml aria-label=网络编程><a href=https://docs.oracle.com/javase/tutorial/networking/index.html>网络编程</a></a></li>
<li>
<a href=#gui-%e7%bc%96%e7%a8%8bhttpsdocsoraclecomjavasetutorialuiswingindexhtml aria-label="GUI 编程"><a href=https://docs.oracle.com/javase/tutorial/uiswing/index.html>GUI 编程</a></a></li>
<li>
<a href=#%e7%9f%a5%e8%af%86%e7%82%b9%e4%b9%8b%e5%a4%96 aria-label=知识点之外>知识点之外</a></li>
<li>
<a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p><strong>注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。</strong></p>
<p><strong>若文中存在任何问题或有任何疑问请前往 <a href=https://github.com/xqm32/xqm32.github.io/issues/new>Issue</a> 页面。</strong></p>
<h2 id=概述httpsdocsoraclecomjavasetutorialgetstartedintroindexhtml><a href=https://docs.oracle.com/javase/tutorial/getStarted/intro/index.html>概述</a><a hidden class=anchor aria-hidden=true href=#概述httpsdocsoraclecomjavasetutorialgetstartedintroindexhtml>#</a></h2>
<ol>
<li>
<p><code>Java</code> 发展历史：</p>
<p>① 1990 年代初由 <code>Sun</code> 公司开发，最初被命名为 <code>Oak</code>，用于家用电器；</p>
<p>② 1995 年，<code>Sun</code> 改造了 <code>Oak</code>，以 <code>Java</code> 的名称正式发布，广泛应用于互联网。</p>
</li>
<li>
<p><a href=https://www.oracle.com/topics/technologies/newtojava/programming-center.html#Get_Started><code>J2ME</code>、<code>J2SE</code>、<code>J2EE</code></a>：</p>
<p><code>J2ME</code>：<strong>J</strong>ava <strong>2</strong> Platform, <strong>M</strong>icro <strong>E</strong>dition，应用于嵌入式（embedded）及移动设备（mobile device）；</p>
<p><code>J2SE</code>：<strong>J</strong>ava <strong>2</strong> Platform, <strong>S</strong>tandard <strong>E</strong>dition，应用于桌面（desktop）及服务器（server）环境；</p>
<p><code>J2EE</code>：<strong>J</strong>ava <strong>2</strong> Platform, <strong>E</strong>nterprise <strong>E</strong>dition，应用于分布式计算（distributed computing）及网络服务（web services），是 <code>J2SE</code> 的拓展。</p>
</li>
<li>
<p><code>Java</code> 语言的特点：</p>
<p>开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（<code>WORA</code>）；</p>
<blockquote>
<p><strong><code>WORA</code></strong>：<strong>W</strong>rite <strong>O</strong>ne, <strong>R</strong>un <strong>A</strong>nywhere</p>
</blockquote>
</li>
<li>
<p><code>Java</code> 与 <code>C++</code> 的比较：</p>
<p>① <code>Java</code> 无<strong>指针</strong>；</p>
<p>② <code>Java</code> 无<strong>结构体</strong>和<strong>联合体</strong>；</p>
<p>③ <code>Java</code> 无<strong>运算符重载</strong>；</p>
<p>④ <code>Java</code> 无<strong>多重继承</strong>，以**接口（<code>interface</code>）**取代；</p>
<p>⑤ <code>Java</code> 无<strong>头文件</strong>和<strong>预处理</strong>；</p>
<p>⑥ <code>Java</code> 无 <strong><code>goto</code></strong> 关键字；</p>
<p>⑦ <code>Java</code> 有 <strong><code>GC</code>（Garbage Collection，垃圾回收）</strong>；</p>
</li>
<li>
<p><a href=https://www.oracle.com/cn/java/technologies/documentation/whitepapers-jsp.html><code>JVM</code>、<code>JRE</code>、<code>JDK</code> 的区别与联系</a>：</p>
<p><img loading=lazy src=java-se-platform.webp alt=java-se-platform>
</p>
<p><code>JVM</code>：<strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine（<code>Java</code> 虚拟机），是执行 <code>Java</code> 字节码的虚拟机，能够执行编译后 <code>Java</code> 语言编写的程序；</p>
<p><code>JRE</code>：<strong>J</strong>ava <strong>R</strong>untime <strong>E</strong>nvironment（<code>Java</code> 运行时），包含了 <code>JVM</code>，和标准类库（Class Library），用户需要安装 <code>JRE</code> 来运行 <code>Java</code> 程序；</p>
<p><code>JDK</code>：<strong>J</strong>ava <strong>D</strong>evelopment <strong>K</strong>it（<code>Java</code> 开发工具包），包含了 <code>JRE</code>，开发者需要安装 <code>JDK</code> 来编译、调试 <code>Java</code> 程序。</p>
</li>
<li>
<p><code>Java</code> 源代码（<code>.java</code> 文件）由编译器（<code>javac</code>）编译为字节码（<code>.class</code> 文件）再由解释器（<code>java</code>）执行。</p>
</li>
<li>
<p>一份 <code>Java</code> 源代码可以包含多个类的定义，但仅能有一个 <code>public</code> 修饰的类，且文件名须与此类一致。</p>
<blockquote>
<p>A class may be declared with the modifier <code>public</code>, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as <em>package-private</em>), it is visible only within its own package (packages are named groups of related classes — you will learn about them in a later lesson.)</p>
</blockquote>
</li>
<li>
<p><code>Java</code> 的编译器：<code>javac</code>，解释器：<code>java</code>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/environment/paths.html><code>PATH</code> 和 <code>CLASSPATH</code></a>：</p>
<p><code>PATH</code> 中应包含 <code>Java</code> 的编译器、解释器等可执行程序；</p>
<p><code>CLASSPATH</code> 中应包含除标准类库外所需的类的路径（包含当前路径 <code>.</code>）。</p>
</li>
<li>
<p>包的定义：<code>package</code>；</p>
<p>包的导入：<code>import</code>。</p>
</li>
</ol>
<h2 id=java-的语法>Java 的语法<a hidden class=anchor aria-hidden=true href=#java-的语法>#</a></h2>
<ol start=11>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html>标识符的命名</a>：</p>
<p>一个合法的标识符应当是一个：<strong>以 <code>Unicode</code> 字符、<code>$</code> 字符或 <code>_</code> 字符开头</strong>，由 <strong><code>Unicode</code> 字符和数字</strong>组成的，<strong>不限长度</strong>的，<strong>从未被使用过</strong>的字符序列。</p>
<p><strong>注意</strong>：一个合法的标识符不应是<strong>关键字</strong>、<strong>保留字</strong>（<code>const</code>、<code>goto</code>）或<strong>字面量</strong>（<code>true</code>、<code>false</code>、<code>null</code>）。</p>
</li>
<li>
<p><code>Java</code> 的数据类型：</p>
<p><a href=https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html><code>Java</code> 的原始数据类型</a>（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>、<code>char</code>）、<a href=https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html><code>Java</code> 的数组</a>、<a href=https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html><code>Java</code> 的类</a>、<a href=https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html><code>Java</code> 的接口</a>、<a href=https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html><code>Java</code> 的枚举类型</a>；</p>
<p><code>Java</code> 的原始数据类型使用值传递，<code>Java</code> 的复杂数据类型使用地址传递（* 笔者的理解是因为内存的占用，值传递和地址传递占用的内存大致相同）。</p>
</li>
<li>
<p><code>Java</code> 中的 <code>char</code> 类型使用 <code>2</code> 字节的 <code>Unicode</code> 编码。</p>
</li>
<li>
<p><code>Java</code> 中 <code>8</code> 个原始数据类型对应着 <code>8</code> 个类型的封装。</p>
</li>
<li>
<p><code>Java</code> 中的字符串类：<code>String</code>、<code>StringBuffer</code>；</p>
<p><code>String</code> 的典型方法：<code>equals()</code>、<code>indexOf()</code>。</p>
</li>
<li>
<p><code>Java</code> 中的类型转换：遵循<a href=https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99>里氏替换原则</a>，精度损失视为错误。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html><code>Java</code> 中的数组</a>，拥有内置的（built-in）<code>length</code> 属性。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/nutsandbolts/branch.html><code>Java</code> 控制流中的分支语句</a>：<code>break</code>、<code>continue</code> 可以控制带有标号的控制语句。</p>
</li>
<li>
<p>参考 PPT 中生成随机数数组的例题（* 也可参考 Java Tutorial 中的例子）。</p>
</li>
</ol>
<h2 id=面向对象编程httpsdocsoraclecomjavasetutorialjavaconceptsindexhtml><a href=https://docs.oracle.com/javase/tutorial/java/concepts/index.html>面向对象编程</a><a hidden class=anchor aria-hidden=true href=#面向对象编程httpsdocsoraclecomjavasetutorialjavaconceptsindexhtml>#</a></h2>
<ol start=20>
<li>
<p>面向对象编程（OOP）的三大特征：<strong>继承</strong>、<strong>封装</strong>、<strong>多态</strong>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html>类的声明</a>、<a href=https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html>成员变量的声明</a>、<a href=https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html>方法的定义</a>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html>静态成员（类变量、类方法）</a>：</p>
<p>不被推荐（discouraged）但正确的类方法的调用：<code>instanceName.methodName(args)</code>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html>构造方法</a>：</p>
<p>① 与类同名；</p>
<p>② 无返回值；</p>
<p>③ 由关键字 <code>new</code> 调用；</p>
<p>④ 可重载，但每两个重载的构造方法不应当<strong>同时</strong>有相同数量、相同类型且相同顺序的参数（确保无歧义）；</p>
<p>⑤ 若未定义构造方法，编译器将默认提供一个无参的构造方法。</p>
<p><strong>注意</strong>：构造方法不是成员。</p>
<blockquote>
<p>A subclass inherits all the <em>members</em> (fields, methods, and nested classes) from its superclass. <strong>Constructors are not members</strong>, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.</p>
</blockquote>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html>访问控制</a>：</p>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Class</th>
<th>Package</th>
<th>Subclass</th>
<th>World</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>no modifier</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td><code>private</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>（* 没有修饰符表示包内私有（package-private））</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html>继承</a>：</p>
<p>① 除了没有父类的 <code>Object</code> 类，每一个类都<strong>有且只有一个</strong>父类（单重继承）；</p>
<p>② <code>Object</code> 类是所有类的隐式（implicitly）父类；</p>
<p>③ 子类将继承一切父类公有（public）或保护（protected）的成员（包括：属性（fields）、方法（methods）、嵌套类（nested classes））。</p>
<p><strong>注意</strong>：① 构造方法不是成员，故而不被子类继承，但可以被子类调用；② 嵌套类（nested class）可以访问其外部类的所有私有成员，因而子类可以通过其间接访问父类的成员。</p>
</li>
<li>
<p>重载（Overload）与<a href=https://docs.oracle.com/javase/tutorial/java/IandI/override.html>重写（Override）</a>：</p>
<p>重载：重载的方法具有<strong>相同</strong>的方法名，<strong>不同</strong>的<strong>参数数量、类型或顺序</strong>；</p>
<p>重写：重写的方法具有<strong>相同</strong>的<strong>方法名</strong>、<strong>参数的数量、类型</strong>和顺序与相同或为其子类的<strong>返回类型</strong>。</p>
</li>
<li>
<p>关键字 <code>this</code> 和 <code>super</code>：</p>
<p><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html><code>this</code> 关键字</a>：用于区分自身属性和外部参数；</p>
<p><a href=https://docs.oracle.com/javase/tutorial/java/IandI/super.html><code>super</code> 关键字</a>：用于重写时区分父类与子类的参数或调用父类的构造方法。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/IandI/override.html>方法重写的原则</a>：</p>
<p>要满足<a href=https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99>里氏替换原则</a>，因而有 ① 访问权限不应比父类更严格；② 抛出的异常不应比父类更多。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html>多态（polymorphism）</a>：运行时多态、编译时多态。</p>
<blockquote>
<p>The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable&rsquo;s type. This behavior is referred to as <em>virtual method invocation</em> and demonstrates an aspect of the important polymorphism features in the Java language.</p>
</blockquote>
</li>
<li>
<p>运行时多态的两个前提：① 上溯造型；② 方法重写。</p>
</li>
<li>
<p><code>final</code> 关键字：</p>
<p>修饰变量：不可被<strong>修改</strong>，为常量；</p>
<p>修饰方法：不可被<strong>重写</strong>；</p>
<p>修饰类：不可被<strong>继承</strong>。</p>
</li>
</ol>
<h2 id=抽象httpsdocsoraclecomjavasetutorialjavaiandiabstracthtml><a href=https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html>抽象</a><a hidden class=anchor aria-hidden=true href=#抽象httpsdocsoraclecomjavasetutorialjavaiandiabstracthtml>#</a></h2>
<ol start=32>
<li><a href=https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html>抽象（<code>abstract</code> 关键字）</a>，可以修饰类和方法，也可修饰接口，但那是不必要的（unnecessary）。</li>
<li>抽象类：<code>abstract</code> 关键字修饰的类，<strong>不能实例化</strong>（* 但不代表不能有一个抽象类型的变量）。</li>
<li>抽象方法：<code>abstract</code> 关键字修饰的方法，<strong>没有实现</strong>。</li>
<li>抽象类中有<strong>任意数量</strong>的抽象方法和<strong>任意数量</strong>的非抽象方法。</li>
<li>非抽象方法可以调用抽象方法（只有 <code>abstract</code> 关键字修饰的类拥有抽象方法）（* 由于实例必然是一个非抽象类，调用的抽象方法将一定被实现）。</li>
<li>非抽象子类应当实现继承的抽象父类的所有抽象方法和抽象父类的未实现的接口（只有 <code>abstract</code> 关键字修饰的类拥有抽象方法）。</li>
<li>抽象类存在的必要性：通过抽象方法规定子类必须完成的方法（动作）。</li>
</ol>
<h2 id=接口httpsdocsoraclecomjavasetutorialjavaiandicreateinterfacehtml><a href=https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html>接口</a><a hidden class=anchor aria-hidden=true href=#接口httpsdocsoraclecomjavasetutorialjavaiandicreateinterfacehtml>#</a></h2>
<ol start=39>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html>接口（<code>interface</code> 关键字）</a>，只包含常量（constants）和抽象方法（* 实际上还有方法签名（method signatures）、默认方法（default methods））。</p>
<p>实现（<code>implements</code> 关键字）。</p>
</li>
<li>
<p>接口中的常量<strong>无需修饰</strong>，默认为 <code>public static final</code>；方法亦无需修饰，默认为 <code>public abstract</code>。</p>
</li>
<li>
<p>一个类可以实现<strong>多个</strong>接口，接口也可以实现接口。</p>
</li>
<li>
<p>非抽象类应当实现接口的<strong>所有方法</strong>（* 可以理解为抽象只存在于抽象中，实际上 <code>default</code> 关键字修饰的无需实现）。</p>
</li>
</ol>
<h2 id=内部类httpsdocsoraclecomjavasetutorialjavajavaoonestedhtml><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html>内部类</a><a hidden class=anchor aria-hidden=true href=#内部类httpsdocsoraclecomjavasetutorialjavajavaoonestedhtml>#</a></h2>
<p><strong>注意</strong>：内部类（inner class）<strong>不是</strong>静态嵌套类（static nested class）</p>
<p>① 内部类不能有 <code>static</code> 修饰的成员（属性、方法）（* 存疑，编译时无问题，但 Java Tutorial 明确说明）。</p>
<blockquote>
<p>As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object&rsquo;s methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.</p>
</blockquote>
<p>② 内部类可以访问外部类的所有成员。</p>
<h2 id=系统类httpsdocsoraclecomjavasetutorialessentialindexhtml><a href=https://docs.oracle.com/javase/tutorial/essential/index.html>系统类</a><a hidden class=anchor aria-hidden=true href=#系统类httpsdocsoraclecomjavasetutorialessentialindexhtml>#</a></h2>
<ol start=43>
<li>
<p><code>Object</code> 类是所有类的父类（间接父类）。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html><code>Object</code> 类</a>：</p>
<p><code>Object::equals(Object obj)</code>：是否是同一个对象（地址相同）；</p>
<p><code>Object::getClass()</code>：获取对象的<strong>运行时类</strong>；</p>
<p><code>Object::toString()</code>：转换为字符串，相当于 <code>getClass().getName() + '@' + Integer.toHexString(hashCode())</code>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html><code>String</code> 类</a>：</p>
<p><code>String::equals(Object obj)</code>：当且仅当 <code>obj</code> 参数不为 <code>null</code>、类型为 <code>String</code> 且所存储的字符序列相同时返回 <code>true</code>（* 也就是该方法的参数不必须是一个 <code>String</code>）。</p>
<p><code>String::length()</code>：返回字符串的长度，这是一个<strong>方法</strong>，注意与数组的 <code>length</code> <strong>属性</strong> 区分。</p>
<p><code>String::compareTo(String anotherString)</code>：顺序为<strong>字典序</strong>；若前置字符均相同，则短字符串排于长字符串之前。</p>
</li>
<li>
<p>原始数据类型与 <code>String</code> 中的转换：</p>
<p>原始数据类型转换为 <code>String</code>：使用 <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#valueOf(boolean)><code>String.valueOf()</code> 方法</a> 或用加法运算符；</p>
<p><code>String</code> 转换为原始数据类型：使用如 <code>Integer.parseInt</code> 式的方法。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Vector.html><code>Vector</code> 列表</a>和 <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ArrayList.html><code>ArrayList</code> 列表</a>：<code>Vector</code> 是**线程安全（thread-safe）**的，但如果线程安全不是必须，更推荐使用 <code>ArrayList</code>。</p>
</li>
</ol>
<h2 id=异常处理httpsdocsoraclecomjavasetutorialessentialexceptionsindexhtml><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html>异常处理</a><a hidden class=anchor aria-hidden=true href=#异常处理httpsdocsoraclecomjavasetutorialessentialexceptionsindexhtml>#</a></h2>
<ol start=48>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html>异常处理的基本概念</a>，<a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html>异常处理的优势</a>。</p>
</li>
<li>
<p><code>JVM</code> 中的运行时错误和 <code>Java</code> 的异常类的对应关系：由 <code>JVM</code> 对应。</p>
</li>
<li>
<p>PPT 中关于异常的图：</p>
<p><img loading=lazy src=exceptions-jvm.svg alt=exceptions-jvm>
</p>
</li>
<li>
<p><code>Java</code> 中的异常类：</p>
<p><img loading=lazy src=exceptions-throwable.gif alt=exceptions-throwable>
</p>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html>运行时异常</a>（<code>RuntimeException</code> 及其子类，又称 <code>unchecked Exception</code>）：编译器将不会检查异常的捕获情况（* <strong>PPT 中认为</strong>运行时异常一定是程序的错误）。</p>
<blockquote>
<p>If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.</p>
</blockquote>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html>异常的处理方法</a>：</p>
<p>① <code>try-catch-finally</code> 捕获异常；</p>
<p>② 使用 <code>throws</code> 关键字，不进行处理。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html><code>throws</code> 关键字</a>：指定（specify）一个方法<strong>可能</strong>抛出的所有异常，非运行时异常可以不被指定；</p>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html><code>throw</code> 关键字</a>：抛出的是一个 <code>Throwable</code> 对象。</p>
</li>
</ol>
<h2 id=输入输出流httpsdocsoraclecomjavasetutorialessentialioindexhtml><a href=https://docs.oracle.com/javase/tutorial/essential/io/index.html>输入输出流</a><a hidden class=anchor aria-hidden=true href=#输入输出流httpsdocsoraclecomjavasetutorialessentialioindexhtml>#</a></h2>
<ol start=54>
<li>
<p>输入输出流的四个抽象类：</p>
<p>① <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/InputStream.html><code>InputStream</code> 抽象类</a>：以字节（byte）为单位进行输入；</p>
<p>② <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/OutputStream.html><code>OutputStream</code> 抽象类</a>：以字节（byte）为单位进行输出；</p>
<p>③ <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Reader.html><code>Reader</code> 抽象类</a>：以字符（character）为单位进行输入；</p>
<p>④ <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Writer.html><code>Writer</code> 抽象类</a>：以字符（character）为单位进行输出。</p>
</li>
<li>
<p>能够用字节流、字符流编写文件的拷贝程序。</p>
<p>字节流：<code>InputStream::read()</code> 到达文件的终止位时将会返回 <code>-1</code>。</p>
<blockquote>
<p>If no byte is available because the end of the stream has been reached, the value <code>-1</code> is returned.</p>
</blockquote>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/File.html><code>File</code> 类</a>：<code>File::File(String pathname)</code>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/InputStreamReader.html><code>InputStreamReader</code> 类</a>、<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/OutputStreamWriter.html><code>OutputStreamWriter</code> 类</a>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/BufferedReader.html><code>BufferedReader</code> 类</a>、<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/BufferedWriter.html><code>BufferedWriter</code> 类</a>。</p>
</li>
</ol>
<h2 id=多线程httpsdocsoraclecomjavasetutorialessentialconcurrencyprocthreadhtml><a href=https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html>多线程</a><a hidden class=anchor aria-hidden=true href=#多线程httpsdocsoraclecomjavasetutorialessentialconcurrencyprocthreadhtml>#</a></h2>
<ol start=59>
<li>
<p>继承 <code>Thread</code> 类或实现 <code>Runnable</code> 接口来完成多线程。</p>
</li>
<li>
<p>多线程的四种状态图，参考 PPT（* <code>stop()</code> 已经<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.html#stop()><strong>废弃（Deprecated）</strong></a>了）。</p>
</li>
<li>
<p>编写多线程程序的两种方法：</p>
<p>① 继承 <code>Thread</code> 类，重写 <code>run()</code> 方法。</p>
<p>② 实现 <code>Runnable</code> 接口，并通过其构造一个 <code>Thread</code> 类。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html>锁和同步</a>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.html#sleep(long)><code>Thread.sleep(long millis)</code> 方法</a>、<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.html#currentThread()><code>Thread.currentThread()</code> 方法</a>。</p>
</li>
</ol>
<h2 id=网络编程httpsdocsoraclecomjavasetutorialnetworkingindexhtml><a href=https://docs.oracle.com/javase/tutorial/networking/index.html>网络编程</a><a hidden class=anchor aria-hidden=true href=#网络编程httpsdocsoraclecomjavasetutorialnetworkingindexhtml>#</a></h2>
<ol start=64>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/networking/urls/index.html><code>URL</code> 类</a>，<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/URL.html><code>URL</code> 类的 <code>API</code></a>：</p>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/URL.html#openStream()><code>URL::openStream</code> 方法</a>：返回一个字节输入流（<code>InputStream</code>）。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html><code>Socket</code> 类通信</a>，<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/Socket.html><code>Socket</code> 类的 <code>API</code></a>，<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/ServerSocket.html><code>ServerSocket</code> 类的 <code>API</code></a>。</p>
</li>
</ol>
<h2 id=gui-编程httpsdocsoraclecomjavasetutorialuiswingindexhtml><a href=https://docs.oracle.com/javase/tutorial/uiswing/index.html>GUI 编程</a><a hidden class=anchor aria-hidden=true href=#gui-编程httpsdocsoraclecomjavasetutorialuiswingindexhtml>#</a></h2>
<ol start=66>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/uiswing/components/index.html>各类组件</a>。</p>
</li>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/uiswing/components/frame.html><code>Frame</code> 容器</a>、<a href=https://docs.oracle.com/javase/tutorial/uiswing/components/panel.html><code>Panel</code> 容器</a>；</p>
<p><code>Windows</code>、<code>Frame</code> 容器的默认布局为 <code>BorderLayout</code>；</p>
<p><code>Panel</code>、<code>Applet</code> 容器的默认布局为 <code>FlowLayout</code>。</p>
</li>
<li>
<p>容器的常用方法 <code>add()</code>、<code>setLayout()</code>、<code>setSize()</code>。</p>
</li>
<li>
<p><code>AWT</code> 事件监听模型，参考 PPT。</p>
</li>
<li>
<p><code>Button</code> 的消息响应：可以参考 Java Tutorial 中的<a href=https://docs.oracle.com/javase/tutorial/uiswing/components/button.html>例子</a>。</p>
</li>
</ol>
<h2 id=知识点之外>知识点之外<a hidden class=anchor aria-hidden=true href=#知识点之外>#</a></h2>
<p>以下是除了课程老师给的知识点参考之外的知识点</p>
<ol start=71>
<li>
<p><a href=https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html>Lambda 表达式</a>：</p>
<blockquote>
<p>A functional interface is any interface that contains only one <a href=https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html>abstract method</a>. (A functional interface may contain one or more <a href=https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html>default methods</a> or <a href=https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static>static methods</a>.) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it.</p>
</blockquote>
<p>语法：<code>() -> {}</code>（* 亦可使用简写）；</p>
</li>
<li>
<p><a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/InputStream.html><code>InputStream</code> 字节输入流</a>、<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/OutputStream.html><code>OutputStream</code> 字节输出流</a>的一些方法：</p>
<p><code>InputStream::readAllBytes()</code>：读取所有的字节，返回一个字节数组；</p>
<p><code>OutputStream::write(byte [])</code>：写入字节数组。</p>
</li>
<li>
<p><code>IOException</code> 是非运行时异常，必须被捕获。</p>
</li>
</ol>
<h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2>
<ol>
<li><a href=https://www.oracle.com/cn/java/technologies/documentation/whitepapers-jsp.html>Java SE 参考资料 — 白皮书</a>；</li>
<li><a href=https://docs.oracle.com/en/java/javase/17/docs/api/index.html>Java SE 17 & JDK 17 API Specification</a>；</li>
<li><a href=https://docs.oracle.com/javase/tutorial/index.html>The Java Tutorials</a>。</li>
</ol>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://xqm32.github.io/tags/java/>Java</a></li>
<li><a href=https://xqm32.github.io/tags/hfut/>HFUT</a></li>
<li><a href=https://xqm32.github.io/tags/%E8%AF%BE%E7%A8%8B/>课程</a></li>
</ul>
</footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css>
<script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<div id=gitalk-container></div>
<script>var gitalk=new Gitalk({clientID:'effe960551db601801d0',clientSecret:'273d97946210e4a1e06df08497f5085dc1c32a5d',repo:'xqm32.github.io',owner:'xqm32',admin:['xqm32'],id:location.pathname,distractionFreeMode:!1});gitalk.render('gitalk-container')</script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://xqm32.github.io/>Qiming's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='复制';function d(){a.innerText='已复制！',setTimeout(()=>{a.innerText='复制'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>