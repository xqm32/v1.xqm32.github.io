---
title: "2023.1"
draft: false
---

# 2023.2.23

```python
#
# @lc app=leetcode.cn id=541 lang=python3
#
# [541] 反转字符串 II
#

# @lc code=start
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        ans: str = ""
        i = 0
        while i < len(s):
            ans += "".join(reversed(s[i : i + k]))
            ans += s[i + k : i + 2 * k]
            i += 2 * k
        return ans


# @lc code=end
sol = Solution()
print(sol.reverseStr(s="abcdefg", k=2))
```

# 2023.2.22

```python
#
# @lc app=leetcode.cn id=2027 lang=python3
#
# [2027] 转换字符串的最少操作次数
#

# @lc code=start
import re


class Solution:
    def minimumMoves(self, s: str) -> int:
        return len(re.findall(r"X.{0,2}", s))


# @lc code=end
```

# 2023.2.21

```python
#
# @lc app=leetcode.cn id=1619 lang=python3
#
# [1619] 删除某些元素后的数组均值
#

# @lc code=start
from typing import List


class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr.sort()
        n5 = len(arr) // 20
        return sum(arr[n5:-n5]) / (len(arr) - 2 * n5)


# @lc code=end
```

# 2023.2.20

```python
#
# @lc app=leetcode.cn id=2409 lang=python3
#
# [2409] 统计共同度过的日子数
#

# @lc code=start
from datetime import datetime


class Solution:
    def countDaysTogether(
        self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str
    ) -> int:
        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

        def foo(bar: str):
            m, d = bar.split("-")
            mi, di = int(m), int(d)
            return sum(days[: mi - 1]) + di

        arrive = (foo(arriveAlice), foo(arriveBob))
        leave = (foo(leaveAlice), foo(leaveBob))
        ans = min(leave) - max(arrive) + 1
        return 0 if ans < 0 else ans


# @lc code=end


sol = Solution()
print(
    sol.countDaysTogether(
        arriveAlice="08-15", leaveAlice="08-18", arriveBob="08-16", leaveBob="08-19"
    )
)
```

# 2023.2.19

```python
#
# @lc app=leetcode.cn id=2481 lang=python3
#
# [2481] 分割圆的最少切割次数
#

# @lc code=start
class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        if n % 2 == 0:
            return n // 2
        return n


# @lc code=end
```

# 2023.2.18

```python
#
# @lc app=leetcode.cn id=2475 lang=python3
#
# [2475] 数组中不等三元组的数目
#

# @lc code=start
from typing import List


class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)):
            for j in range(i, len(nums)):
                for k in range(j, len(nums)):
                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:
                        ans += 1
        return ans


# @lc code=end
```

# 2023.2.17

```python
#
# @lc app=leetcode.cn id=2446 lang=python3
#
# [2446] 判断两个事件是否存在冲突
#

# @lc code=start
from typing import List


class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        s1, e1 = event1
        s2, e2 = event2
        s1h, s1m = s1.split(":")
        e1h, e1m = e1.split(":")
        s2h, s2m = s2.split(":")
        e2h, e2m = e2.split(":")

        def t(h: str, m: str):
            return int(h) * 60 + int(m)

        s1t, e1t = t(s1h, s1m), t(e1h, e1m)
        s2t, e2t = t(s2h, s2m), t(e2h, e2m)

        if s1t > s2t:
            s1t, e1t, s2t, e2t = s2t, e2t, s1t, e1t

        if e1t >= s2t:
            return True
        else:
            return False


# @lc code=end
sol = Solution()
print(sol.haveConflict(["10:00", "11:00"], ["14:00", "15:00"]))
```

# 2023.2.16

```python
#
# @lc app=leetcode.cn id=2451 lang=python3
#
# [2451] 差值数组不同的字符串
#

# @lc code=start
from typing import List


class Solution:
    def oddString(self, words: List[str]) -> str:
        def diff(s: str):
            return [ord(s[i]) - ord(s[i - 1]) for i in range(1, len(s))]

        l = list(map(diff, words))
        a = l[0]
        for i in range(1, len(l)):
            if a != l[i]:
                if i != 1:
                    return words[i]
                elif a == l[2]:
                    return words[1]
                else:
                    return words[0]
        return ""


# @lc code=end
sol = Solution()
print(sol.oddString(["adc", "wzy", "abc"]))
print(sol.oddString(["aaa", "bob", "ccc", "ddd"]))
```

# 2023.2.15

```python
#
# @lc app=leetcode.cn id=2460 lang=python3
#
# [2460] 对数组执行操作
#

# @lc code=start
from typing import List


class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        nums.append(-1)
        ans = []
        zero = 0

        for i in range(len(nums) - 1):
            if nums[i] == 0:
                zero += 1
                continue

            if nums[i] == nums[i + 1]:
                ans.append(nums[i] * 2)
                nums[i + 1] = 0
            else:
                ans.append(nums[i])

        return ans + zero * [0]


# @lc code=end
sol = Solution()
print(sol.applyOperations([1, 2, 2, 1, 1, 0]))
```

# 2023.2.14

```python
#
# @lc app=leetcode.cn id=2441 lang=python3
#
# [2441] 与对应负数同时存在的最大正整数
#

# @lc code=start
from typing import List


class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        s = set(nums)
        for i in sorted(s, reverse=True):
            if -i in s:
                return i
        return -1


# @lc code=end
```

# 2023.2.13

```python
#
# @lc app=leetcode.cn id=2455 lang=python3
#
# [2455] 可被三整除的偶数的平均值
#

# @lc code=start
from typing import List


class Solution:
    def averageValue(self, nums: List[int]) -> int:
        n = [i for i in nums if i % 3 == 0 and i % 2 == 0]
        return sum(n) // len(n) if len(n) != 0 else 0


# @lc code=end
```

# 2023.2.12

```python
#
# @lc app=leetcode.cn id=2469 lang=python3
#
# [2469] 温度转换
#

# @lc code=start
import math
from typing import List


class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius + 273.15, celsius * 1.8 + 32.00]


# @lc code=end
```

# 2023.2.11

```python
#
# @lc app=leetcode.cn id=2465 lang=python3
#
# [2465] 不同的平均值数目
#

# @lc code=start
from typing import List


class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        n = len(nums)
        nums.sort()

        a, b = nums[: n // 2], list(reversed(nums[n // 2 :]))

        return len({(i + j) / 2 for i, j in zip(a, b)})


# @lc code=end
```

# 2023.2.10

```python
#
# @lc app=leetcode.cn id=2347 lang=python3
#
# [2347] 最好的扑克手牌
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:
        if len(set(suits)) == 1:
            return "Flush"

        ranks_counter = Counter(ranks).values()

        if max(ranks_counter) >= 3:
            return "Three of a Kind"
        elif max(ranks_counter) == 2:
            return "Pair"

        return "High Card"


# @lc code=end
```

# 2023.2.9

```python
#
# @lc app=leetcode.cn id=1995 lang=python3
#
# [1995] 统计特殊四元组
#

# @lc code=start
from typing import List


class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        ans = 0

        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    for l in range(k + 1, len(nums)):
                        if nums[i] + nums[j] + nums[k] == nums[l]:
                            ans += 1

        return ans


# @lc code=end
```

# 2023.2.8

```python
#
# @lc app=leetcode.cn id=1991 lang=python3
#
# [1991] 找到数组的中间位置
#

# @lc code=start
from itertools import accumulate
from typing import List


class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        s = sum(nums)
        a = [0] + list(accumulate(nums, lambda i, j: i + j)) + [0]
        for i in range(1, len(a) - 1):
            if a[i - 1] == s - a[i]:
                return i - 1
        return -1


# @lc code=end
sol = Solution()
print(sol.findMiddleIndex(nums=[2, 3, -1, 8, 4]))
print(sol.findMiddleIndex(nums=[1, -1, 4]))
```

# 2023.2.7

```python
#
# @lc app=leetcode.cn id=1979 lang=python3
#
# [1979] 找出数组的最大公约数
#

# @lc code=start
from math import gcd
from typing import List


class Solution:
    def findGCD(self, nums: List[int]) -> int:
        return gcd(min(nums), max(nums))


# @lc code=end
```

# 2023.2.6

```python
#
# @lc app=leetcode.cn id=1974 lang=python3
#
# [1974] 使用特殊打字机键入单词的最少时间
#

# @lc code=start
class Solution:
    def minTimeToType(self, word: str) -> int:
        ans = 0
        p = ord("a")
        for i in word:
            ans += min(abs(ord(i) - p), 26 - abs(ord(i) - p)) + 1
            p = ord(i)
        return ans


# @lc code=end
sol = Solution()
print(sol.minTimeToType("abc"))
```

# 2023.2.5

```python
#
# @lc app=leetcode.cn id=1893 lang=python3
#
# [1893] 检查是否区域内所有整数都被覆盖
#

# @lc code=start
from typing import List


class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        ranges.sort(key=lambda i: i[0])
        a = ranges[0]
        for i in ranges[1:]:
            if a[0] <= left and right <= a[1]:
                return True
            if a[1] >= i[0] - 1:
                a[1] = max(a[1], i[1])
            else:
                a = i
        if a[0] <= left and right <= a[1]:
            return True
        return False


# @lc code=end
sol = Solution()
print(sol.isCovered(ranges=[[1, 2], [3, 4], [5, 6]], left=2, right=5))
print(sol.isCovered(ranges=[[1, 10], [10, 20]], left=21, right=21))
```

# 2023.2.4

```python
#
# @lc app=leetcode.cn id=1886 lang=python3
#
# [1886] 判断矩阵经轮转后是否一致
#

# @lc code=start
from typing import List


class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        Mat = List[List[int]]

        n = len(mat)

        def rotate(mat: Mat) -> Mat:
            return [list(reversed(i)) for i in zip(*mat)]

        def eq(a: Mat, b: Mat) -> bool:
            for i in range(n):
                for j in range(n):
                    if a[i][j] != b[i][j]:
                        return False
            return True

        for _ in range(4):
            if not eq(mat, target):
                mat = rotate(mat)
            else:
                return True
        return False


# @lc code=end
sol = Solution()
print(
    sol.findRotation(
        mat=[[0, 0, 0], [0, 1, 0], [1, 1, 1]], target=[[1, 1, 1], [0, 1, 0], [0, 0, 0]]
    )
)
```

# 2023.2.3

```python
#
# @lc app=leetcode.cn id=1863 lang=python3
#
# [1863] 找出所有子集的异或总和再求和
#

# @lc code=start
from functools import reduce
from itertools import combinations
from typing import List


class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        ans = 0
        for i in range(1, len(nums) + 1):
            for j in combinations(nums, i):
                print(j)
                ans += reduce(lambda a, b: a ^ b, j)
        return ans


# @lc code=end
sol = Solution()
print(sol.subsetXORSum(nums=[1, 3]))
```

# 2023.2.2

```python
#
# @lc app=leetcode.cn id=2089 lang=python3
#
# [2089] 找出数组排序后的目标下标
#

# @lc code=start
from typing import List


class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        a = []
        nums.sort()
        for c, i in enumerate(nums):
            if i == target:
                a.append(c)
        return a


# @lc code=end
sol = Solution()
print(sol.targetIndices(nums=[1, 2, 5, 2, 3], target=2))
```

# 2023.2.1

```python
#
# @lc app=leetcode.cn id=832 lang=python3
#
# [832] 翻转图像
#

# @lc code=start
from typing import List


class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        for i in image:
            i.reverse()
        for i in image:
            for j in range(len(i)):
                if i[j] == 0:
                    i[j] = 1
                else:
                    i[j] = 0
        return image


# @lc code=end
sol = Solution()
print(sol.flipAndInvertImage([[1, 1, 0], [1, 0, 1], [0, 0, 0]]))
```

# 2023.1.31

```python
#
# @lc app=leetcode.cn id=2085 lang=python3
#
# [2085] 统计出现过一次的公共字符串
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        a, b = Counter(words1), Counter(words2)
        al = list(filter(lambda i: i[1] == 1, a.items()))
        bl = list(filter(lambda i: i[1] == 1, b.items()))
        return len({i[0] for i in al}.intersection(({i[0] for i in bl})))


# @lc code=end
sol = Solution()
print(
    sol.countWords(
        words1=["leetcode", "is", "amazing", "as", "is"],
        words2=["amazing", "leetcode", "is"],
    )
)
```

# 2023.1.30

```python
#
# @lc app=leetcode.cn id=350 lang=python3
#
# [350] 两个数组的交集 II
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        a, b = Counter(nums1), Counter(nums2)
        c = set(nums1).intersection(set(nums2))
        d = {i: min(a[i], b[i]) for i in c}
        e = []
        for i in c:
            e.extend([i] * d[i])
        return e


# @lc code=end
sol = Solution()
print(sol.intersect(nums1=[1, 2, 2, 1], nums2=[2, 2]))
```

# 2023.1.29

```python
#
# @lc app=leetcode.cn id=2351 lang=python3
#
# [2351] 第一个出现两次的字母
#

# @lc code=start
class Solution:
    def repeatedCharacter(self, s: str) -> str:
        d = dict()
        for i in s:
            if i not in d:
                d[i] = 1
            else:
                return i
        return ""


# @lc code=end
```

# 2023.1.28

```python
#
# @lc app=leetcode.cn id=2124 lang=python3
#
# [2124] 检查是否所有 A 都在 B 之前
#

# @lc code=start
class Solution:
    def checkString(self, s: str) -> bool:
        a = s.split("b", maxsplit=1)
        if len(a) == 1:
            return True
        if "a" in a[1]:
            return False
        return True


# @lc code=end
```

# 2023.1.27

```python
#
# @lc app=leetcode.cn id=2367 lang=python3
#
# [2367] 算术三元组的数目
#

# @lc code=start
from typing import List


class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        ans = 0
        for i in range(len(nums)):
            if nums[i] + diff in nums[i + 1 :] and nums[i] + diff * 2 in nums[i + 2 :]:
                ans += 1
        return ans


# @lc code=end
```

# 2023.1.26

```python
#
# @lc app=leetcode.cn id=2108 lang=python3
#
# [2108] 找出数组中的第一个回文字符串
#

# @lc code=start
from typing import List


class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        def func(s: str) -> bool:
            for i, j in zip(s, "".join(reversed(s))):
                if i != j:
                    return False
            return True

        for i in words:
            if func(i):
                return i
        return ""


# @lc code=end
sol = Solution()
print(sol.firstPalindrome(["abc", "car", "ada", "racecar", "cool"]))
```

# 2023.1.25

```python
#
# @lc app=leetcode.cn id=2357 lang=python3
#
# [2357] 使数组中所有元素都等于零
#

# @lc code=start
from typing import List


class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        return len(set(nums) - {0})


# @lc code=end
```

# 2023.1.24

```python
#
# @lc app=leetcode.cn id=1768 lang=python3
#
# [1768] 交替合并字符串
#

# @lc code=start
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        ans = ""
        for i, j in zip(word1, word2):
            ans += i + j
        l1, l2 = len(word1), len(word2)
        if l1 > l2:
            ans += word1[l2 - l1 :]
        elif l2 > l1:
            ans += word2[l1 - l2 :]
        return ans


# @lc code=end
sol = Solution()
print(sol.mergeAlternately(word1="ab", word2="pqrs"))
```

# 2023.1.23

```python
#
# @lc app=leetcode.cn id=1984 lang=python3
#
# [1984] 学生分数的最小差值
#

# @lc code=start
from typing import List


class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        return min(nums[i + k - 1] - nums[i] for i in range(len(nums) - k + 1))


# @lc code=end
sol = Solution()
print(sol.minimumDifference(nums=[90], k=1))
print(sol.minimumDifference(nums=[9, 4, 1, 7], k=2))
```

# 2023.1.22

```python
#
# @lc app=leetcode.cn id=1897 lang=python3
#
# [1897] 重新分配字符使所有字符串都相等
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        return all(i % len(words) == 0 for i in Counter("".join(words)).values())


# @lc code=end
```

# 2023.1.21

```python
#
# @lc app=leetcode.cn id=1967 lang=python3
#
# [1967] 作为子字符串出现在单词中的字符串数目
#

# @lc code=start
from typing import List


class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        return sum(i in word for i in patterns)


# @lc code=end
```

# 2023.1.20

```python
#
# @lc app=leetcode.cn id=1961 lang=python3
#
# [1961] 检查字符串是否为数组前缀
#

# @lc code=start
from typing import List


class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        a, b = 0, 0
        for i in words:
            b = a + len(i)
            if s[a:b] != i:
                break
            a += len(i)

        if a == len(s):
            return True
        else:
            return False


# @lc code=end
sol = Solution()
print(sol.isPrefixString(s="iloveleetcode", words=["i", "love", "leetcode", "apples"]))
print(sol.isPrefixString(s="iloveleetcode", words=["apples", "i", "love", "leetcode"]))
```

# 2023.1.19

```python
#
# @lc app=leetcode.cn id=1957 lang=python3
#
# [1957] 删除字符使字符串变好
#

# @lc code=start
class Solution:
    def makeFancyString(self, s: str) -> str:
        count = 1
        ans = s[0]
        for i in s[1:]:
            if i != ans[-1]:
                ans += i
                count = 1
            elif count < 2:
                ans += i
                count += 1
            else:
                count += 1
        return ans


# @lc code=end
sol = Solution()
print(sol.makeFancyString("leeeeeeetcode"))
```

# 2023.1.18

```
#
# @lc app=leetcode.cn id=1929 lang=python3
#
# [1929] 数组串联
#

# @lc code=start
from typing import List


class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums * 2


# @lc code=end
```

# 2023.1.17

```python
#
# @lc app=leetcode.cn id=1945 lang=python3
#
# [1945] 字符串转化后的各位数字之和
#

# @lc code=start
class Solution:
    def getLucky(self, s: str, k: int) -> int:
        s = "".join(str(ord(i) - ord("a") + 1) for i in s)
        for i in range(k):
            s = str(sum(int(i) for i in s))
        return int(s)


# @lc code=end
```

# 2023.1.16

```python
#
# @lc app=leetcode.cn id=2259 lang=python3
#
# [2259] 移除指定数字得到的最大结果
#

# @lc code=start
class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        ans = 0
        for i in range(len(number)):
            if number[i] == digit:
                ans = max(ans, int(number[:i] + number[i + 1 :]))
        return str(ans)


# @lc code=end
sol = Solution()
print(sol.removeDigit(number="123", digit="3"))
print(sol.removeDigit(number="1231", digit="1"))
print(sol.removeDigit(number="551", digit="5"))
print(sol.removeDigit(number="133235", digit="3"))
print(sol.removeDigit(number="2464", digit="6"))
print(sol.removeDigit(number="15454", digit="4"))
```

# 2023.1.15

```python
#
# @lc app=leetcode.cn id=1859 lang=python3
#
# [1859] 将句子排序
#

# @lc code=start
class Solution:
    def sortSentence(self, s: str) -> str:
        a: list[str] = [""] * 9
        for i in s.split():
            a[int(i[-1]) - 1] = i[:-1]
        return " ".join(a).strip()


# @lc code=end
```

# 2023.1.14

```python
#
# @lc app=leetcode.cn id=1582 lang=python3
#
# [1582] 二进制矩阵中的特殊位置
#

# @lc code=start
from typing import List


class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        rows, cols = len(mat), len(mat[0])
        sumRows, sumCols = [0] * rows, [0] * cols
        for i in range(rows):
            sumRows[i] = sum(mat[i])
        matT = list(zip(*mat))
        for i in range(cols):
            sumCols[i] = sum(matT[i])
        ans = 0
        for i in range(rows):
            for j in range(cols):
                if mat[i][j] == 1:
                    if sumRows[i] == 1 and sumCols[j] == 1:
                        ans += 1
                    break
        return ans


# @lc code=end
```

# 2023.1.13

```python
#
# @lc app=leetcode.cn id=1408 lang=python3
#
# [1408] 数组中的字符串匹配
#

# @lc code=start
from typing import List


class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        res = []
        words.sort(key=lambda i: len(i))
        for i in range(len(words)):
            if words[i] in " ".join(words[i + 1 :]):
                res.append(words[i])
        return res


# @lc code=end
```

# 2023.1.12

```python
#
# @lc app=leetcode.cn id=459 lang=python3
#
# [459] 重复的子字符串
#

# @lc code=start
from math import ceil, floor, sqrt
import re


class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        a = {1}
        for i in range(2, floor(sqrt(len(s))) + 1):
            if len(s) % i == 0:
                a.update({i, len(s) // i})
        for i in sorted(a, reverse=True):
            if re.match(f"^({s[:i]}){{2,}}$", s):
                return True
        return False


# @lc code=end

sol = Solution()
print(sol.repeatedSubstringPattern("abab"))
print(sol.repeatedSubstringPattern("aba"))
print(sol.repeatedSubstringPattern("abcabcabc"))
print(sol.repeatedSubstringPattern("abcabc"))
print(sol.repeatedSubstringPattern("abaababaab"))
print(sol.repeatedSubstringPattern("bb"))
```

# 2023.1.11

```python
#
# @lc app=leetcode.cn id=441 lang=python3
#
# [441] 排列硬币
#

# @lc code=start
from math import floor, sqrt


class Solution:
    def arrangeCoins(self, n: int) -> int:
        return int((pow(8 * n + 1, 0.5) - 1) / 2)


# @lc code=end
sol = Solution()
print(sol.arrangeCoins(5))
print(sol.arrangeCoins(20))
print(sol.arrangeCoins(3000))
```

# 2023.1.10

```python
#
# @lc app=leetcode.cn id=1403 lang=python3
#
# [1403] 非递增顺序的最小子序列
#

# @lc code=start
from typing import List


class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums.sort(reverse=True)
        a, b, sb = sum(nums), [], 0
        for i in nums:
            if sb > a:
                return b
            b.append(i)
            sb += i
            a -= i
        return b


# @lc code=end
```

# 2023.1.9

```python
#
# @lc app=leetcode.cn id=680 lang=python3
#
# [680] 验证回文串 II
#

# @lc code=start
class Solution:
    def validPalindrome(self, s: str) -> bool:
        r = "".join(reversed(s))
        for i in range(len(s)):
            if r[i] != s[i]:
                ra = r[: len(s) - i - 1] + r[len(s) - i :]
                sa = s[:i] + s[i + 1 :]
                rb = r[:i] + r[i + 1 :]
                sb = s[: len(s) - i - 1] + s[len(s) - i :]
                # print(ra, sa)
                # print(rb, sb)
                return ra == sa or rb == sb
        return True


# @lc code=end
sol = Solution()
print(sol.validPalindrome("aba"))
print(sol.validPalindrome("abca"))
print(sol.validPalindrome("acba"))
print(sol.validPalindrome("abc"))
print(sol.validPalindrome("eedede"))
print(sol.validPalindrome("ebcbbececabbacecbbcbe"))
print(sol.validPalindrome("cbbcc"))
```

# 2023.1.8

```python
#
# @lc app=leetcode.cn id=1436 lang=python3
#
# [1436] 旅行终点站
#

# @lc code=start
from typing import List


class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        a = dict(paths)
        b = paths[0][0]
        while b in a.keys():
            b = a[b]
        return b


# @lc code=end

sol = Solution()
print(
    sol.destCity([["London", "New York"], ["New York", "Lima"], ["Lima", "Sao Paulo"]])
)
```

# 2023.1.7

```python
#
# @lc app=leetcode.cn id=1464 lang=python3
#
# [1464] 数组中两元素的最大乘积
#

# @lc code=start
from typing import List


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        a = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                a = max(a, (nums[i] - 1) * (nums[j] - 1))
        return a


# @lc code=end
```

# 2023.1.6

```python
#
# @lc app=leetcode.cn id=1356 lang=python3
#
# [1356] 根据数字二进制下 1 的数目排序
#

# @lc code=start
from functools import cmp_to_key
from typing import List


class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        def cmp(a, b):
            if a.bit_count() > b.bit_count():
                return 1
            elif a.bit_count() < b.bit_count():
                return -1
            else:
                if a > b:
                    return 1
                elif a < b:
                    return -1
                else:
                    return 0

        return sorted(arr, key=cmp_to_key(cmp))


# @lc code=end
sol = Solution()
print(sol.sortByBits([0, 1, 2, 3, 4, 5, 6, 7, 8]))
```

# 2023.1.5

```python
#
# @lc app=leetcode.cn id=2210 lang=python3
#
# [2210] 统计数组中峰和谷的数量
#

# @lc code=start
from typing import List


class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        sign = 0
        ans = 0
        for i in range(1, len(nums) - 1):
            if nums[i - 1] > nums[i] < nums[i + 1]:
                sign = 0
                ans += 1
            elif nums[i - 1] < nums[i] > nums[i + 1]:
                sign = 0
                ans += 1
            elif nums[i - 1] == nums[i] < nums[i + 1] and sign == 1:
                sign = 0
                ans += 1
            elif nums[i - 1] == nums[i] > nums[i + 1] and sign == -1:
                sign = 0
                ans += 1
            elif nums[i - 1] < nums[i] == nums[i + 1]:
                sign = -1
            elif nums[i - 1] > nums[i] == nums[i + 1]:
                sign = 1
        return ans


# @lc code=end
sol = Solution()
print(sol.countHillValley([1, 2, 1, 2, 2, 1, 1, 2]))
print(sol.countHillValley([2, 4, 1, 1, 6, 5]))
```

# 2023.1.4

```python
#
# @lc app=leetcode.cn id=1763 lang=python3
#
# [1763] 最长的美好子字符串
#

# @lc code=start


class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        toNice = [s]
        result = []
        while len(toNice) != 0:
            # print("toNice", toNice)
            i = toNice.pop(0)
            notNice = ""
            for j in i:
                if j.isupper() and j.lower() in i:
                    continue
                elif j.islower() and j.upper() in i:
                    continue
                else:
                    notNice += j
            # print("notNice", notNice)
            if notNice == "":
                if len(i) > 0:
                    result.append(i)
            else:
                for c in notNice:
                    i = i.replace(c, " ")
                toNice = i.split() + toNice
        answer = ""
        for i in result:
            if len(i) > len(answer):
                answer = i
        return answer


# @lc code=end
sol = Solution()
print(sol.longestNiceSubstring("FeOZJEnNfjz"))
print(sol.longestNiceSubstring("wWOExoVhvXebB"))
print(sol.longestNiceSubstring("YazaAay"))
print(sol.longestNiceSubstring("Bb"))
print(sol.longestNiceSubstring("c"))
print(sol.longestNiceSubstring("dDzeE"))
```

# 2023.1.3

```python
#
# @lc app=leetcode.cn id=2404 lang=python3
#
# [2404] 出现最频繁的偶数元素
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        a = list(filter(lambda i: i % 2 == 0, nums))
        if len(a) == 0:
            return -1
        b = Counter(a).most_common()
        c = [i[0] for i in filter(lambda i: i[1] == b[0][1], b)]
        return min(c)


# @lc code=end
sol = Solution()
print(sol.mostFrequentEven([0, 1, 2, 2, 4, 4, 1]))
```

# 2023.1.2

```python
#
# @lc app=leetcode.cn id=1046 lang=python3
#
# [1046] 最后一块石头的重量
#

# @lc code=start
from typing import List


class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:

        while len(stones) > 1:
            stones.sort()
            a = stones.pop()
            b = stones.pop()
            if a <= b:
                x, y = a, b
            else:
                y, x = a, b

            if x != y:
                stones.append(y - x)

        if len(stones) == 1:
            return stones.pop()
        else:
            return 0


# @lc code=end
```

# 2023.1.1

```python
#
# @lc app=leetcode.cn id=1071 lang=python3
#
# [1071] 字符串的最大公因子
#

# @lc code=start
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        short: str = ""
        long: str = ""

        if len(str1) < len(str2):
            short, long = str1, str2
        else:
            short, long = str2, str1

        def canDivide(l: str, s: str) -> bool:
            # print(f"l({len(l)}): {l}, s({len(s)}): {s}")
            for i in range(0, len(l), len(s)):
                # print(f"{i}-{i+len(s)}: {l[: i + len(s)]}")
                if l[i : i + len(s)] != s:
                    return False
            return True

        for i in reversed(range(1, len(short) + 1)):
            if canDivide(long, short[:i]) and canDivide(short, short[:i]):
                return short[:i]
        return ""


# @lc code=end
sol = Solution()
print(sol.gcdOfStrings(str1="ABCABC", str2="ABC"))
print(sol.gcdOfStrings(str1="ABABAB", str2="ABAB"))
print(sol.gcdOfStrings(str1="LEET", str2="CODE"))
print(sol.gcdOfStrings("AAAAA", "AAAAAAA"))
```
