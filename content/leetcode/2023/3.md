---
title: "2023.3"
draft: false
---

# 2022.3.13

```python
#
# @lc app=leetcode.cn id=1773 lang=python3
#
# [1773] 统计匹配检索规则的物品数量
#

# @lc code=start
from typing import List


class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        rule = {"type": 0, "color": 1, "name": 2}
        return sum(1 for item in items if item[rule[ruleKey]] == ruleValue)


# @lc code=end
```

# 2022.3.12

```python
#
# @lc app=leetcode.cn id=697 lang=python3
#
# [697] 数组的度
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        counter_nums = Counter(nums)
        cn_values = counter_nums.values()
        max_value = max(cn_values)
        max_nums = [k for k, v in counter_nums.items() if v == max_value]

        reversed_nums = list(reversed(nums))
        min_len = len(nums)
        for i in max_nums:
            i_len = (len(nums) - reversed_nums.index(i)) - nums.index(i)
            if i_len < min_len:
                min_len = i_len

        return min_len


# @lc code=end
```

# 2022.3.11

```python
#
# @lc app=leetcode.cn id=1646 lang=python3
#
# [1646] 获取生成数组中的最大值
#


# @lc code=start
class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        nums = [0] * (n + 1)
        nums[1] = 1
        for i in range(2, n + 1):
            if i % 2 == 0:
                nums[i] = nums[i // 2]
            else:
                nums[i] = nums[i // 2] + nums[i // 2 + 1]
        return max(nums)


# @lc code=end
```

# 2022.3.10

```python
#
# @lc app=leetcode.cn id=415 lang=python3
#
# [415] 字符串相加
#


# @lc code=start
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        res = ""
        i = len(num1) - 1
        j = len(num2) - 1
        carry = 0
        while i >= 0 or j >= 0 or carry != 0:
            if i >= 0:
                carry += int(num1[i])
                i -= 1
            if j >= 0:
                carry += int(num2[j])
                j -= 1
            res += str(carry % 10)
            carry //= 10
        return res[::-1]


# @lc code=end
```

# 2022.3.9

```python
#
# @lc app=leetcode.cn id=747 lang=python3
#
# [747] 至少是其他数字两倍的最大数
#

# @lc code=start
from typing import List


class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        # len(nums) >= 1
        if len(nums) == 1:
            return 0

        m1, m2 = 0, 1
        for i in range(1, len(nums)):
            if nums[i] > nums[m1]:
                m2 = m1
                m1 = i
            elif nums[i] > nums[m2]:
                m2 = i

        if nums[m1] >= 2 * nums[m2]:
            return m1
        else:
            return -1


# @lc code=end
sol = Solution()
print(sol.dominantIndex([3, 6, 1, 0]))
print(sol.dominantIndex([1, 2, 3, 4]))
print(sol.dominantIndex([0, 0, 3, 2]))
```

# 2022.3.8

```python
#
# @lc app=leetcode.cn id=1652 lang=python3
#
# [1652] 拆炸弹
#

# @lc code=start
from typing import List


class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        code_length = len(code)
        code = code * 3
        if k == 0:
            return [0] * code_length
        elif k > 0:
            return [sum(code[i + 1 : i + k + 1]) for i in range(code_length)]
        else:
            return [sum(code[i + k : i]) for i in range(code_length, code_length * 2)]


# @lc code=end
```

# 2022.3.7

```python
#
# @lc app=leetcode.cn id=1346 lang=python3
#
# [1346] 检查整数及其两倍数是否存在
#

# @lc code=start
from typing import List


class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        if arr.count(0) > 1:
            return True

        ans = set(arr) - {0}
        return any(i * 2 in ans for i in ans)


# @lc code=end
```

# 2022.3.6

```python
#
# @lc app=leetcode.cn id=405 lang=python3
#
# [405] 数字转换为十六进制数
#


# @lc code=start
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return "0"
        if num < 0:
            num += 2**32
        ans = ""
        while num:
            ans = "0123456789abcdef"[num % 16] + ans
            num //= 16
        return ans


# @lc code=end``
```

# 2022.3.5

```python
#
# @lc app=leetcode.cn id=2363 lang=python3
#
# [2363] 合并相似的物品
#

# @lc code=start
from typing import List


class Solution:
    def mergeSimilarItems(
        self, items1: List[List[int]], items2: List[List[int]]
    ) -> List[List[int]]:
        dict = {i[0]: i[1] for i in items1}
        for i in items2:
            if i[0] in dict:
                dict[i[0]] += i[1]
            else:
                dict[i[0]] = i[1]
        return [[k, v] for k, v in sorted(dict.items(), key=lambda x: x[0])]


# @lc code=end
```

# 2022.3.4

```python
#
# @lc app=leetcode.cn id=1700 lang=python3
#
# [1700] 无法吃午餐的学生数量
#

# @lc code=start
from typing import List


class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        while True:
            if students[0] == sandwiches[0]:
                students.pop(0)
                sandwiches.pop(0)
            else:
                if len(set(students)) == 1:
                    return len(students)
                students.append(students.pop(0))

            if not students:
                return 0


# @lc code=end
```

# 2022.3.3

```python
#
# @lc app=leetcode.cn id=2389 lang=python3
#
# [2389] 和有限的最长子序列
#

# @lc code=start
from typing import List


class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        ans = []
        for i in range(1, len(nums)):
            nums[i] = nums[i - 1] + nums[i]
        for q in queries:
            for i in range(len(nums)):
                if nums[i] > q:
                    ans.append(i)
                    break
            else:
                ans.append(len(nums))
        return ans


# @lc code=end
```

# 2022.3.2

```python
#
# @lc app=leetcode.cn id=2037 lang=python3
#
# [2037] 使每位学生都有座位的最少移动次数
#

# @lc code=start
from typing import List


class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats.sort()
        students.sort()
        ans = 0
        for i in range(len(seats)):
            ans += abs(seats[i] - students[i])
        return ans


# @lc code=end
```

# 2022.3.1

```python
#
# @lc app=leetcode.cn id=2006 lang=python3
#
# [2006] 差的绝对值为 K 的数对数目
#

# @lc code=start
from typing import List


class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        ans = 0
        nums.sort()

        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if abs(nums[i] - nums[j]) == k:
                    ans += 1

        return ans


# @lc code=end
```
