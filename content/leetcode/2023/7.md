---
title: "2023.7"
draft: false
---

# 2023.7.14

```python
#
# @lc app=leetcode.cn id=153 lang=python3
#
# [153] 寻找旋转排序数组中的最小值
#

# @lc code=start
from typing import List


class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 二分查找
        # 时间复杂度：O(logn)
        # 空间复杂度：O(1)
        left, right = 0, len(nums) - 1
        while left < right:
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            if nums[mid] < nums[right]:
                # mid 在右边递增区间
                right = mid
            else:
                # mid 在左边递增区间
                left = mid + 1
        return nums[left]


# @lc code=end
```

# 2023.7.13

```python
#
# @lc app=leetcode.cn id=122 lang=python3
#
# [122] 买卖股票的最佳时机 II
#

# @lc code=start
from typing import List


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0

        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit = profit + prices[i] - prices[i - 1]

        return profit


# @lc code=end
```

# 2023.7.12

```python
#
# @lc app=leetcode.cn id=187 lang=python3
#
# [187] 重复的DNA序列
#

# @lc code=start
from collections import defaultdict
from typing import List


L = 10


class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        ans = []
        cnt = defaultdict(int)
        for i in range(len(s) - L + 1):
            sub = s[i : i + L]
            cnt[sub] += 1
            if cnt[sub] == 2:
                ans.append(sub)
        return ans


# @lc code=end
```

# 2023.7.11

```python
#
# @lc app=leetcode.cn id=872 lang=python3
#
# [872] 叶子相似的树
#
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional


class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        def dfs(root: Optional[TreeNode], leaves: list[int]) -> None:
            if not root:
                return
            if not root.left and not root.right:
                leaves.append(root.val)
                return
            dfs(root.left, leaves)
            dfs(root.right, leaves)

        leaves1, leaves2 = list(), list()
        dfs(root1, leaves1)
        dfs(root2, leaves2)
        return leaves1 == leaves2


# @lc code=end
```

# 2023.7.10

```python
#
# @lc app=leetcode.cn id=700 lang=python3
#
# [700] 二叉搜索树中的搜索
#

from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        def dfs(root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
            if not root:
                return None
            if root.val == val:
                return root
            elif root.val < val:
                return dfs(root.right, val)
            else:
                return dfs(root.left, val)

        return dfs(root, val)


# @lc code=end
```

# 2023.7.9

```python
#
# @lc app=leetcode.cn id=637 lang=python3
#
# [637] 二叉树的层平均值
#

from typing import List, Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        def dfs(root: Optional[TreeNode], depth: int):
            if not root:
                return
            if depth >= len(sum_list):
                sum_list.append([0, 0])
            sum_list[depth][0] += root.val
            sum_list[depth][1] += 1
            dfs(root.left, depth + 1)
            dfs(root.right, depth + 1)

        sum_list = []
        dfs(root, 0)
        return [s / c for s, c in sum_list]


# @lc code=end
```

# 2023.7.8

```python
#
# @lc app=leetcode.cn id=617 lang=python3
#
# [617] 合并二叉树
#


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional


class Solution:
    def mergeTrees(
        self, root1: Optional[TreeNode], root2: Optional[TreeNode]
    ) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root1:
            return root2
        if not root2:
            return root1
        root = TreeNode(root1.val + root2.val)
        root.left = self.mergeTrees(root1.left, root2.left)
        root.right = self.mergeTrees(root1.right, root2.right)
        return root


# @lc code=end
```

# 2023.7.7

```python
#
# @lc app=leetcode.cn id=599 lang=python3
#
# [599] 两个列表的最小索引总和
#

# @lc code=start
from typing import List


class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d1 = {c: i for i, c in enumerate(list1)}
        d2 = {c: i for i, c in enumerate(list2)}
        res = []
        min_sum = float("inf")
        for c in d1:
            if c in d2:
                if d1[c] + d2[c] < min_sum:
                    res = [c]
                    min_sum = d1[c] + d2[c]
                elif d1[c] + d2[c] == min_sum:
                    res.append(c)
        return res


# @lc code=end
```

# 2023.7.6

```python
#
# @lc app=leetcode.cn id=590 lang=python3
#
# [590] N 叉树的后序遍历
#

from typing import List


class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


# @lc code=start
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""


class Solution:
    def postorder(self, root: "Node") -> List[int]:
        def dfs(root: "Node"):
            if not root:
                return
            for child in root.children:
                dfs(child)
            res.append(root.val)

        res = []
        dfs(root)
        return res


# @lc code=end
```

# 2023.7.5

```python
#
# @lc app=leetcode.cn id=589 lang=python3
#
# [589] N 叉树的前序遍历
#


from typing import List


class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


# @lc code=start
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""


class Solution:
    def preorder(self, root: "Node") -> List[int]:
        def dfs(root: "Node"):
            if not root:
                return
            res.append(root.val)
            for child in root.children:
                dfs(child)

        res = []
        dfs(root)
        return res


# @lc code=end
```

# 2023.7.4

```python
#
# @lc app=leetcode.cn id=572 lang=python3
#
# [572] 另一棵树的子树
#


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional


class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        def dfs(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
            if not root and not subRoot:
                return True
            if not root or not subRoot or root.val != subRoot.val:
                return False
            return dfs(root.left, subRoot.left) and dfs(root.right, subRoot.right)

        if not root:
            return False
        return (
            dfs(root, subRoot)
            or self.isSubtree(root.left, subRoot)
            or self.isSubtree(root.right, subRoot)
        )


# @lc code=end
```

# 2023.7.3

```python
#
# @lc app=leetcode.cn id=566 lang=python3
#
# [566] 重塑矩阵
#

# @lc code=start
from typing import List


class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m, n, k = len(mat), len(mat[0]), r * c
        if m * n != k:
            return mat
        res = [[0] * c for _ in range(r)]
        for i in range(k):
            res[i // c][i % c] = mat[i // n][i % n]
        return res


# @lc code=end
```

# 2023.7.2

```python
#
# @lc app=leetcode.cn id=563 lang=python3
#
# [563] 二叉树的坡度
#

from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        def dfs(root: Optional[TreeNode]) -> int:
            if not root:
                return 0
            left_sum = dfs(root.left)
            right_sum = dfs(root.right)
            nonlocal tilt_sum
            tilt_sum += abs(left_sum - right_sum)
            return left_sum + right_sum + root.val

        tilt_sum = 0
        dfs(root)
        return tilt_sum


# @lc code=end
```

# 2023.7.1

```python
#
# @lc app=leetcode.cn id=559 lang=python3
#
# [559] N 叉树的最大深度
#
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


# @lc code=start
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""


class Solution:
    def maxDepth(self, root: "Node") -> int:
        def dfs(root: "Node", depth: int):
            if not root:
                return
            if not root.children:
                nonlocal max_depth
                max_depth = max(max_depth, depth)
            for child in root.children:
                dfs(child, depth + 1)

        max_depth = 0
        dfs(root, 1)
        return max_depth


# @lc code=end
```
