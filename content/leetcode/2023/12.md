---
title: 2023.12
draft: false
---

# 2023.12.20

```python
#
# @lc app=leetcode.cn id=524 lang=python3
#
# [524] 通过删除字母匹配到字典里最长单词
#

# @lc code=start
from typing import List


class Solution:
    def findLongestWord(self, s: str, dictionary: List[str]) -> str:
        dictionary.sort(key=lambda x: (-len(x), x))
        for word in dictionary:
            i = j = 0
            while i < len(s) and j < len(word):
                if s[i] == word[j]:
                    j += 1
                i += 1
            if j == len(word):
                return word
        return ""


# @lc code=end
```

# 2023.12.19

```python
#
# @lc app=leetcode.cn id=609 lang=python3
#
# [609] 在系统中查找重复文件
#

# @lc code=start
from typing import List


class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        dic = {}
        for path in paths:
            path_split = path.split(" ")
            root = path_split[0]
            for file in path_split[1:]:
                file_split = file.split("(")
                file_name = file_split[0]
                file_content = file_split[1][:-1]
                if file_content not in dic:
                    dic[file_content] = []
                dic[file_content].append(root + "/" + file_name)
        res = []
        for key, value in dic.items():
            if len(value) > 1:
                res.append(value)
        return res


# @lc code=end
```

# 2023.12.18

```python
#
# @lc app=leetcode.cn id=890 lang=python3
#
# [890] 查找和替换模式
#

# @lc code=start
from typing import List


class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        def check(word):
            m1, m2 = {}, {}
            for w, p in zip(word, pattern):
                if w not in m1:
                    m1[w] = p
                if p not in m2:
                    m2[p] = w
                if (m1[w], m2[p]) != (p, w):
                    return False
            return True

        return list(filter(check, words))


# @lc code=end
```

# 2023.12.17

```python
#
# @lc app=leetcode.cn id=1333 lang=python3
#
# [1333] 餐厅过滤器
#

# @lc code=start
from typing import List


class Solution:
    def filterRestaurants(
        self,
        restaurants: List[List[int]],
        veganFriendly: int,
        maxPrice: int,
        maxDistance: int,
    ) -> List[int]:
        restaurants = filter(
            lambda x: x[2] >= veganFriendly
            and x[3] <= maxPrice
            and x[4] <= maxDistance,
            restaurants,
        )
        restaurants = sorted(restaurants, key=lambda x: (x[1], x[0]), reverse=True)
        return [x[0] for x in restaurants]


# @lc code=end
```

# 2023.12.16

```python
#
# @lc app=leetcode.cn id=30 lang=python3
#
# [30] 串联所有单词的子串
#

# @lc code=start
from typing import List


class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not s or not words:
            return []
        one_word = len(words[0])
        all_len = len(words) * one_word
        n = len(s)
        words = sorted(words)
        res = []
        for i in range(n - all_len + 1):
            tmp = []
            for j in range(i, i + all_len, one_word):
                tmp.append(s[j : j + one_word])
            tmp = sorted(tmp)
            if tmp == words:
                res.append(i)
        return res


# @lc code=end
```

# 2023.12.15

```python
#
# @lc app=leetcode.cn id=433 lang=python3
#
# [433] 最小基因变化
#

# @lc code=start
from typing import List


class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        bank = set(bank)
        queue = [(startGene, 0)]
        while queue:
            gene, step = queue.pop(0)
            if gene == endGene:
                return step
            for i in range(len(gene)):
                for c in "ACGT":
                    newGene = gene[:i] + c + gene[i + 1 :]
                    if newGene in bank:
                        queue.append((newGene, step + 1))
                        bank.remove(newGene)
        return -1


# @lc code=end
```

# 2023.12.14

```python
#
# @lc app=leetcode.cn id=540 lang=python3
#
# [540] 有序数组中的单一元素
#

# @lc code=start
from typing import List


class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        left, right = 0, n - 1
        while left < right:
            mid = left + ((right - left) >> 1)
            if mid % 2 == 1:
                mid -= 1
            if nums[mid] == nums[mid + 1]:
                left = mid + 2
            else:
                right = mid
        return nums[left]


# @lc code=end
```

# 2023.12.13

```python
#
# @lc app=leetcode.cn id=714 lang=python3
#
# [714] 买卖股票的最佳时机含手续费
#

# @lc code=start
from typing import List


class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        dp_i_0, dp_i_1 = 0, -prices[0]
        for i in range(1, n):
            tmp = dp_i_0
            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i] - fee)
            dp_i_1 = max(dp_i_1, tmp - prices[i])
        return dp_i_0


# @lc code=end
```

# 2023.12.12

```python
#
# @lc app=leetcode.cn id=893 lang=python3
#
# [893] 特殊等价字符串组
#

# @lc code=start
from typing import List


class Solution:
    def numSpecialEquivGroups(self, words: List[str]) -> int:
        def get_key(word):
            odd = []
            even = []
            for i, c in enumerate(word):
                if i % 2 == 0:
                    even.append(c)
                else:
                    odd.append(c)
            odd.sort()
            even.sort()
            return "".join(odd) + "".join(even)

        return len(set(map(get_key, words)))


# @lc code=end
```

# 2023.12.11

```python
#
# @lc app=leetcode.cn id=665 lang=python3
#
# [665] 非递减数列
#

# @lc code=start
from typing import List


class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        if len(nums) <= 2:
            return True

        count = 0
        for i in range(1, len(nums)):
            if nums[i] < nums[i - 1]:
                count += 1
                if count > 1:
                    return False
                if i - 2 >= 0 and nums[i] < nums[i - 2]:
                    nums[i] = nums[i - 1]
                else:
                    nums[i - 1] = nums[i]
        return True


# @lc code=end
```

# 2023.12.10

```python
#
# @lc app=leetcode.cn id=399 lang=python3
#
# [399] 除法求值
#

# @lc code=start
from typing import List


class Solution:
    def calcEquation(
        self, equations: List[List[str]], values: List[float], queries: List[List[str]]
    ) -> List[float]:
        graph = {}
        for i in range(len(equations)):
            a, b = equations[i]
            if a not in graph:
                graph[a] = {}
            if b not in graph:
                graph[b] = {}
            graph[a][b] = values[i]
            graph[b][a] = 1 / values[i]

        def dfs(a, b, visited):
            if a not in graph or b not in graph:
                return -1
            if b in graph[a]:
                return graph[a][b]
            for c in graph[a]:
                if c not in visited:
                    visited.add(c)
                    res = dfs(c, b, visited)
                    if res != -1:
                        return graph[a][c] * res
            return -1

        res = []
        for a, b in queries:
            res.append(dfs(a, b, set()))
        return res


# @lc code=end
```

# 2023.12.9

```python
#
# @lc app=leetcode.cn id=840 lang=python3
#
# [840] 矩阵中的幻方
#

# @lc code=start
from typing import List


class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])

        def magic(
            a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int
        ) -> bool:
            return sorted([a, b, c, d, e, f, g, h, i]) == list(range(1, 10)) and (
                a + b + c
                == d + e + f
                == g + h + i
                == a + d + g
                == b + e + h
                == c + f + i
                == a + e + i
                == c + e + g
                == 15
            )

        ans = 0
        for r in range(R - 2):
            for c in range(C - 2):
                if grid[r + 1][c + 1] != 5:
                    continue
                if magic(
                    grid[r][c],
                    grid[r][c + 1],
                    grid[r][c + 2],
                    grid[r + 1][c],
                    grid[r + 1][c + 1],
                    grid[r + 1][c + 2],
                    grid[r + 2][c],
                    grid[r + 2][c + 1],
                    grid[r + 2][c + 2],
                ):
                    ans += 1
        return ans


# @lc code=end
```

# 2023.12.8

```python
#
# @lc app=leetcode.cn id=838 lang=python3
#
# [838] 推多米诺
#


# @lc code=start
class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        dominoes = "L" + dominoes + "R"
        ans = ""
        i = 0
        for j in range(1, len(dominoes)):
            if dominoes[j] == ".":
                continue
            middle = j - i - 1
            if i:
                ans += dominoes[i]
            if dominoes[i] == dominoes[j]:
                ans += dominoes[i] * middle
            elif dominoes[i] == "L" and dominoes[j] == "R":
                ans += "." * middle
            else:
                ans += "R" * (middle // 2) + "." * (middle % 2) + "L" * (middle // 2)
            i = j
        return ans


# @lc code=end
```

# 2023.12.7

```python
#
# @lc app=leetcode.cn id=837 lang=python3
#
# [837] 新 21 点
#


# @lc code=start
class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if k == 0 or n >= k + maxPts:
            return 1.0
        dp = [1.0] + [0.0] * n
        Wsum = 1.0
        for i in range(1, n + 1):
            dp[i] = Wsum / maxPts
            if i < k:
                Wsum += dp[i]
            if i >= maxPts:
                Wsum -= dp[i - maxPts]
        return sum(dp[k:])


# @lc code=end
```

# 2023.12.6

```python
#
# @lc app=leetcode.cn id=826 lang=python3
#
# [826] 安排工作以达到最大收益
#

# @lc code=start
from typing import List


class Solution:
    def maxProfitAssignment(
        self, difficulty: List[int], profit: List[int], worker: List[int]
    ) -> int:
        jobs = sorted(zip(difficulty, profit))
        worker.sort()
        i = best = total = 0
        for ability in worker:
            while i < len(jobs) and ability >= jobs[i][0]:
                best = max(jobs[i][1], best)
                i += 1
            total += best
        return total


# @lc code=end
```

# 2023.12.5

```python
#
# @lc app=leetcode.cn id=621 lang=python3
#
# [621] 任务调度器
#

# @lc code=start
from typing import List


class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        task_count = [0] * 26
        for task in tasks:
            task_count[ord(task) - ord("A")] += 1
        task_count.sort()
        max_task_count = task_count.pop()
        max_task_count_num = 1
        while task_count and task_count[-1] == max_task_count:
            max_task_count_num += 1
            task_count.pop()
        return max(len(tasks), (max_task_count - 1) * (n + 1) + max_task_count_num)


# @lc code=end
```

# 2023.12.4

```python
#
# @lc app=leetcode.cn id=1362 lang=python3
#
# [1362] 最接近的因数
#

# @lc code=start
from typing import List


class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        for i in range(int((num + 2) ** 0.5), 0, -1):
            if (num + 1) % i == 0:
                return [i, (num + 1) // i]
            if (num + 2) % i == 0:
                return [i, (num + 2) // i]


# @lc code=end
```

# 2023.12.3

```python
#
# @lc app=leetcode.cn id=957 lang=python3
#
# [957] N 天后的牢房
#

# @lc code=start
from typing import List


class Solution:
    def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:
        seen = dict()
        while n > 0:
            seen[str(cells)] = n
            n -= 1
            cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0]
            if str(cells) in seen:
                n %= seen[str(cells)] - n
        return cells


# @lc code=end
```

# 2023.12.2

```python
#
# @lc app=leetcode.cn id=885 lang=python3
#
# [885] 螺旋矩阵 III
#

# @lc code=start
from typing import List


class Solution:
    def spiralMatrixIII(
        self, rows: int, cols: int, rStart: int, cStart: int
    ) -> List[List[int]]:
        ans = [[rStart, cStart]]
        r, c = rStart, cStart
        step = 1
        while len(ans) < rows * cols:
            for _ in range(step):
                c += 1
                if 0 <= r < rows and 0 <= c < cols:
                    ans.append([r, c])
            for _ in range(step):
                r += 1
                if 0 <= r < rows and 0 <= c < cols:
                    ans.append([r, c])
            step += 1
            for _ in range(step):
                c -= 1
                if 0 <= r < rows and 0 <= c < cols:
                    ans.append([r, c])
            for _ in range(step):
                r -= 1
                if 0 <= r < rows and 0 <= c < cols:
                    ans.append([r, c])
            step += 1
        return ans


# @lc code=end
```

# 2023.12.1

```python
#
# @lc app=leetcode.cn id=560 lang=python3
#
# [560] 和为 K 的子数组
#

# @lc code=start
from typing import List


class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        sum = 0
        count = 0
        hash_map = {0: 1}
        for num in nums:
            sum += num
            count += hash_map.get(sum - k, 0)
            hash_map[sum] = hash_map.get(sum, 0) + 1
        return count


# @lc code=end
```
