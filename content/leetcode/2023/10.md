---
title: 2023.10
draft: false
---

# 2023.10.10

```python
#
# @lc app=leetcode.cn id=279 lang=python3
#
# [279] 完全平方数
#


# @lc code=start
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = i
            for j in range(1, i):
                if j * j <= i:
                    dp[i] = min(dp[i], dp[i - j * j] + 1)
                else:
                    break
        return dp[n]


# @lc code=end
```

# 2023.10.9

```python
#
# @lc app=leetcode.cn id=97 lang=python3
#
# [97] 交错字符串
#


# @lc code=start
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        if len(s1) + len(s2) != len(s3):
            return False

        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]

        dp[0][0] = True

        for i in range(1, len(s1) + 1):
            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]

        for j in range(1, len(s2) + 1):
            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

        for i in range(1, len(s1) + 1):
            for j in range(1, len(s2) + 1):
                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (
                    dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]
                )

        return dp[-1][-1]


# @lc code=end
```

# 2023.10.8

```python
#
# @lc app=leetcode.cn id=525 lang=python3
#
# [525] 连续数组
#

# @lc code=start
from typing import List


class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        pre_sum = 0
        hash_map = {0: -1}
        max_len = 0
        for i, num in enumerate(nums):
            if num == 0:
                pre_sum -= 1
            else:
                pre_sum += 1
            if pre_sum in hash_map:
                max_len = max(max_len, i - hash_map[pre_sum])
            else:
                hash_map[pre_sum] = i
        return max_len


# @lc code=end
```

# 2023.10.7

```python
#
# @lc app=leetcode.cn id=443 lang=python3
#
# [443] 压缩字符串
#

# @lc code=start
from typing import List


class Solution:
    def compress(self, chars: List[str]) -> int:
        if not chars:
            return 0
        if len(chars) == 1:
            return 1

        count = 1
        prev = chars[0]
        index = 0
        for i in range(1, len(chars)):
            if chars[i] == prev:
                count += 1
            else:
                chars[index] = prev
                index += 1
                if count > 1:
                    for c in str(count):
                        chars[index] = c
                        index += 1
                prev = chars[i]
                count = 1

        chars[index] = prev
        index += 1
        if count > 1:
            for c in str(count):
                chars[index] = c
                index += 1

        return index


# @lc code=end
```

# 2023.10.6

```python
#
# @lc app=leetcode.cn id=532 lang=python3
#
# [532] 数组中的 k-diff 数对
#

# @lc code=start
from typing import List


class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        if k < 0:
            return 0
        nums.sort()
        i, j = 0, 1
        res = 0
        while j < len(nums):
            if nums[j] - nums[i] == k:
                res += 1
                i += 1
                j += 1
                while j < len(nums) and nums[j] == nums[j - 1]:
                    j += 1
            elif nums[j] - nums[i] < k:
                j += 1
            else:
                i += 1
                if i == j:
                    j += 1
        return res


# @lc code=end
```

# 2023.10.5

```python
#
# @lc app=leetcode.cn id=397 lang=python3
#
# [397] 整数替换
#


# @lc code=start
class Solution:
    def integerReplacement(self, n: int) -> int:
        res = 0
        while n != 1:
            if n & 1 == 0:
                n >>= 1
            else:
                if (n + 1) & 2 == 0 and n != 3:
                    n += 1
                else:
                    n -= 1
            res += 1
        return res


# @lc code=end
```

# 2023.10.4

```python
#
# @lc app=leetcode.cn id=417 lang=python3
#
# [417] 太平洋大西洋水流问题
#

# @lc code=start
from typing import List


class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        if not heights:
            return []

        m, n = len(heights), len(heights[0])
        pacific, atlantic = set(), set()

        def dfs(i, j, visited):
            visited.add((i, j))
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if (
                    x < 0
                    or x >= m
                    or y < 0
                    or y >= n
                    or (x, y) in visited
                    or heights[x][y] < heights[i][j]
                ):
                    continue
                dfs(x, y, visited)

        for i in range(m):
            dfs(i, 0, pacific)
            dfs(i, n - 1, atlantic)
        for j in range(n):
            dfs(0, j, pacific)
            dfs(m - 1, j, atlantic)

        return list(pacific & atlantic)


# @lc code=end
```

# 2023.10.3

```python
#
# @lc app=leetcode.cn id=648 lang=python3
#
# [648] 单词替换
#

# @lc code=start
from typing import List


class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dictionary = sorted(dictionary, key=lambda x: len(x))
        words = sentence.split(" ")
        for i, word in enumerate(words):
            for root in dictionary:
                if word.startswith(root):
                    words[i] = root
                    break
        return " ".join(words)


# @lc code=end
```

# 2023.10.2

```python
#
# @lc app=leetcode.cn id=189 lang=python3
#
# [189] 轮转数组
#

# @lc code=start
from typing import List


class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        k %= n
        nums[:] = nums[n - k :] + nums[: n - k]


# @lc code=end
```

# 2023.10.1

```python
#
# @lc app=leetcode.cn id=400 lang=python3
#
# [400] 第 N 位数字
#


# @lc code=start
class Solution:
    def findNthDigit(self, n: int) -> int:
        digit, start, count = 1, 1, 9
        while n > count:
            n -= count
            start *= 10
            digit += 1
            count = 9 * start * digit

        num = start + (n - 1) // digit
        return int(str(num)[(n - 1) % digit])


# @lc code=end
```
