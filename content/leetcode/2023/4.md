---
title: "2023.3"
draft: false
---

# 2023.4.4

```python
#
# @lc app=leetcode.cn id=2303 lang=python3
#
# [2303] 计算应缴税款总额
#

# @lc code=start
from typing import List


class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        tax = 0.0
        if income <= brackets[0][0]:
            return income * brackets[0][1] / 100
        else:
            tax += brackets[0][0] * brackets[0][1] / 100
        for i in range(1, len(brackets)):
            if income <= brackets[i][0]:
                tax += (income - brackets[i - 1][0]) * brackets[i][1] / 100
                break
            else:
                tax += (brackets[i][0] - brackets[i - 1][0]) * brackets[i][1] / 100
        return tax


# @lc code=end
sol = Solution()
print(sol.calculateTax(brackets=[[3, 50], [7, 10], [12, 25]], income=10))
```

# 2023.4.3

```python
#
# @lc app=leetcode.cn id=766 lang=python3
#
# [766] 托普利茨矩阵
#

# @lc code=start
from typing import List


class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m, n = len(matrix), len(matrix[0])
        for i in range(m - 1):
            for j in range(n - 1):
                if matrix[i][j] != matrix[i + 1][j + 1]:
                    return False
        return True


# @lc code=end
```

# 2023.4.2

```python
#
# @lc app=leetcode.cn id=496 lang=python3
#
# [496] 下一个更大元素 I
#

# @lc code=start
from typing import List


class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        hashmap = {}
        for num in nums2:
            while stack and stack[-1] < num:
                hashmap[stack.pop()] = num
            stack.append(num)
        return [hashmap.get(num, -1) for num in nums1]


# @lc code=end
```

# 2023.4.1

```python
#
# @lc app=leetcode.cn id=965 lang=python3
#
# [965] 单值二叉树
#

# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional


class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        def dfs(node: TreeNode, val: int) -> bool:
            if not node:
                return True
            if node.val != val:
                return False
            return dfs(node.left, val) and dfs(node.right, val)

        return dfs(root, root.val)


# @lc code=end
```
