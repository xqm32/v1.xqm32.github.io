---
title: "2022.11"
draft: false
---

# 2022.11.14

```python
#
# @lc app=leetcode.cn id=1752 lang=python3
#
# [1752] 检查数组是否经排序和轮转得到
#

# @lc code=start
from typing import List


class Solution:
    def check(self, nums: List[int]) -> bool:
        return (
            sum(i > j for i, j in zip(nums[:-1], nums[1:])) + (nums[-1] > nums[0]) <= 1
        )


# @lc code=end
sol = Solution()
print(sol.check([1]))
print(sol.check([3, 4, 5, 1, 2]))
print(sol.check([2, 1, 3, 4]))
print(sol.check([1, 2, 3]))
print(sol.check([3, 1, 2]))
print(sol.check([1, 3, 2]))
```

# 2022.11.13

```python
#
# @lc app=leetcode.cn id=2220 lang=python3
#
# [2220] 转换数字的最少位翻转次数
#

# @lc code=start
class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        return sum(
            i != j
            for i, j in zip(
                bin(start).lstrip("0b").zfill(goal.bit_length()),
                bin(goal).lstrip("0b").zfill(start.bit_length()),
            )
        )


# @lc code=end
sol = Solution()
print(sol.minBitFlips(0, 0b1111))
print(sol.minBitFlips(3, 4))
```

# 2022.11.12

```python
#
# @lc app=leetcode.cn id=1732 lang=python3
#
# [1732] 找到最高海拔
#

# @lc code=start
class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        return max(max(sum(gain[:i]) for i in range(len(gain) + 1)), 0)


# @lc code=end
```

# 2022.11.11

```python
#
# @lc app=leetcode.cn id=1422 lang=python3
#
# [1422] 分割字符串的最大得分
#

# @lc code=start
class Solution:
    def maxScore(self, s: str) -> int:
        a = s[:1].count("0") + s[1:].count("1")
        ans = a
        for i in s[1:-1]:
            if i == "0":
                a += 1
            else:
                a -= 1
            ans = max(ans, a)
        return ans


# @lc code=end
sol = Solution()
print(sol.maxScore("011101"))
print(sol.maxScore("00111"))
print(sol.maxScore("1111"))
print(sol.maxScore("00"))
```

# 2022.11.10

```python
#
# @lc app=leetcode.cn id=1710 lang=python3
#
# [1710] 卡车上的最大单元数
#

# @lc code=start
from typing import List


class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        ans = 0
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        for i, j in boxTypes:
            if truckSize > i:
                ans += i * j
                truckSize -= i
            else:
                ans += truckSize * j
                break
        return ans


# @lc code=end
sol = Solution()
print(sol.maximumUnits(boxTypes=[[1, 3], [2, 2], [3, 1]], truckSize=4))
print(sol.maximumUnits(boxTypes=[[5, 10], [2, 5], [4, 7], [3, 9]], truckSize=10))
```

# 2022.11.9

```python
#
# @lc app=leetcode.cn id=1221 lang=python3
#
# [1221] 分割平衡字符串
#

# @lc code=start
class Solution:
    def balancedStringSplit(self, s: str) -> int:
        ans = 0
        r = 0
        for i in s:
            if i == "R":
                r += 1
            else:
                r -= 1
            if r == 0:
                ans += 1
        return ans


# @lc code=end
```

# 2022.11.8

```python
#
# @lc app=leetcode.cn id=1588 lang=python3
#
# [1588] 所有奇数长度子数组的和
#

# @lc code=start
from typing import List


class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        return sum(
            sum((sum(arr[j : j + i]) for j in range(0, len(arr) - i + 1)))
            for i in range(1, len(arr) + 1, 2)
        )


# @lc code=end
sol = Solution()
print(sol.sumOddLengthSubarrays([1, 4, 2, 5, 3]))
print(sol.sumOddLengthSubarrays([1, 2]))
print(sol.sumOddLengthSubarrays([10, 11, 12]))
```

# 2022.11.7

```python
#
# @lc app=leetcode.cn id=144 lang=python3
#
# [144] 二叉树的前序遍历
#

# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []

        def traversal(root):
            if root is None:
                return
            ans.append(root.val)
            traversal(root.left)
            traversal(root.right)

        traversal(root)
        return ans


# @lc code=end
```

# 2022.11.6

```python
#
# @lc app=leetcode.cn id=1275 lang=python3
#
# [1275] 找出井字棋的获胜者
#

# @lc code=start
from typing import List


class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        a = [0] * 9
        for i, j in moves[::2]:
            a[i * 3 + j] = 1
        for i, j in moves[1::2]:
            a[i * 3 + j] = -1

        win = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
        ]

        for i, j, k in win:
            if a[i] + a[j] + a[k] == 3:
                return "A"
            elif a[i] + a[j] + a[k] == -3:
                return "B"

        if len(moves) == 9:
            return "Draw"
        else:
            return "Pending"


# @lc code=end
sol = Solution()
print(sol.tictactoe([[0, 0], [2, 0], [1, 1], [2, 1], [2, 2]]))
print(sol.tictactoe([[0, 0], [1, 1], [0, 1], [0, 2], [1, 0], [2, 0]]))
print(
    sol.tictactoe(
        [[0, 0], [1, 1], [2, 0], [1, 0], [1, 2], [2, 1], [0, 1], [0, 2], [2, 2]]
    )
)
print(sol.tictactoe([[0, 0], [1, 1]]))
```

# 2022.11.5

```python
#
# @lc app=leetcode.cn id=1122 lang=python3
#
# [1122] 数组的相对排序
#

# @lc code=start
from collections import Counter
from typing import List


class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        c = Counter(arr1)
        ans = []
        for i in arr2:
            ans.extend([i] * c[i])
        for i in sorted(set(arr1) - set(arr2)):
            ans.extend([i] * c[i])
        return ans


# @lc code=end
```

# 2022.11.4

```python
#
# @lc app=leetcode.cn id=1791 lang=python3
#
# [1791] 找出星型图的中心节点
#

# @lc code=start
from typing import List
from collections import Counter


class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        return Counter(edges[0] + edges[1]).most_common(1)[0][0]


# @lc code=end

sol = Solution()
print(sol.findCenter([[1, 2], [5, 1], [1, 3], [1, 4]]))
```

# 2022.11.3

```python
#
# @lc app=leetcode.cn id=1704 lang=python3
#
# [1704] 判断字符串的两半是否相似
#

# @lc code=start
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        a = s.lower()[: len(s) // 2]
        b = s.lower()[len(s) // 2 :]
        return a.count("a") + a.count("e") + a.count("i") + a.count("o") + a.count(
            "u"
        ) == b.count("a") + b.count("e") + b.count("i") + b.count("o") + b.count("u")


# @lc code=end
```

# 2022.11.2

```python
#
# @lc app=leetcode.cn id=1812 lang=python3
#
# [1812] 判断国际象棋棋盘中一个格子的颜色
#

# @lc code=start
class Solution:
    def squareIsWhite(self, coordinates: str) -> bool:
        return (ord(coordinates[0]) - 96) % 2 != int(coordinates[1]) % 2


# @lc code=end
```

# 2022.11.1

```python
#
# @lc app=leetcode.cn id=2215 lang=python3
#
# [2215] 找出两数组的不同
#

# @lc code=start
from typing import List


class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        return [list(set(nums1).difference(nums2)), list(set(nums2).difference(nums1))]


# @lc code=end
```
