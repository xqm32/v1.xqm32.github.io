[{"content":"搬运一篇笔者在知乎发的文章：C 语言实现字符串切片\n基于 Python 的切片的格式实现的 C 语言字符串切片：\n#include \u0026lt;ctype.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef long long SizeType; size_t fgetln(FILE* stream, char* dest, size_t size) { size_t i; for (i = 0, *dest = fgetc(stream); *dest != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; !feof(stream) \u0026amp;\u0026amp; --size \u0026gt; 0; ++i, *++dest = fgetc(stream)) ; *dest = \u0026#39;\\0\u0026#39;; return i; } // 读取一行字符串。  size_t slice(char* from, char* to, SizeType begin, SizeType end, SizeType interval) { SizeType i; begin += begin \u0026lt; 0 ? strlen(from) : 0; end += end \u0026gt; 0 ? 0 : strlen(from); interval = interval ? interval : 1; for (i = 0; from[begin] != \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; begin \u0026lt; end; ++i, begin += interval) to[i] = from[begin]; to[i] = \u0026#39;\\0\u0026#39;; return i; } // 切片函数。  char* StrSize(char* from, SizeType* m, SizeType* n, SizeType* o) { *m = atoll(from); from = strchr(from, \u0026#39;:\u0026#39;); if (!from) return from; *n = atoll(++from); from = strchr(from, \u0026#39;:\u0026#39;); if (!from) return from; *o = atoll(++from); return from; } // 字符串解析成数字，由 \u0026#34;:\u0026#34; 分隔。  size_t strslice(char* format, char* from, char* to) { SizeType m = 0, n = 0, o = 0; StrSize(format, \u0026amp;m, \u0026amp;n, \u0026amp;o); // printf(\u0026#34;%lld, %lld, %lld\\n\u0026#34;, m, n, o);  return slice(from, to, m, n, o); } // 用字符串作为切片的格式的切片函数。  int main(int argc, char* argv[]) { char* String = malloc(128); char* Format = malloc(128); char* Save = malloc(128); for (;;) { memset(String, 0, 128); memset(Format, 0, 128); memset(Save, 0, 128); fgetln(stdin, String, 128); fgetln(stdin, Format, 128); strslice(Format, String, Save); printf(\u0026#34;%s\\n\u0026#34;, Save); } } 测试：\nHello world :: Hello world Hello world 1 ello world Hello world -1 d Hello world 1: ello world Hello world -1: d Hello world :1 H Hello world :-1 Hello worl Hello world ::1 Hello world Hello world ::2 Hlowrd Hello world 1:-1 ello worl Hello world 2:1 [无输出] Hello world -2:-1 l Hello world -1:-2 [无输出] ","permalink":"http://xqm32.github.io/posts/slicing-string-in-c-language/","summary":"搬运一篇笔者在知乎发的文章：C 语言实现字符串切片\n基于 Python 的切片的格式实现的 C 语言字符串切片：\n#include \u0026lt;ctype.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef long long SizeType; size_t fgetln(FILE* stream, char* dest, size_t size) { size_t i; for (i = 0, *dest = fgetc(stream); *dest != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; !feof(stream) \u0026amp;\u0026amp; --size \u0026gt; 0; ++i, *++dest = fgetc(stream)) ; *dest = \u0026#39;\\0\u0026#39;; return i; } // 读取一行字符串。  size_t slice(char* from, char* to, SizeType begin, SizeType end, SizeType interval) { SizeType i; begin += begin \u0026lt; 0 ?","title":"C 语言实现字符串切片"},{"content":"使用 Github Actions 自动化部署 Hugo 博客 笔者一直想有个属于自己的博客，通过在网上不断搜索，笔者发现使用 Hugo 部署至 Github Pages 上是一个不错的选择。但是，这样的部署也有一个缺陷：需要手动生成部署文件，再上传至 Github，这是十分麻烦的。因此笔者又在网上搜索文档、文章，后来了解到，可以使用 Github Actions 进行自动化部署，我们只需要将网站源码推送至 Github 便可以自动化地生成博客网站。不过，虽然在操作上是方便了许多，但如何配置这样的自动化部署似乎依旧是一个复杂的问题。于是笔者继续在网上搜索文档和文章，但大部分都没有给出较为「官方」的解决方案，也很少有参考资料可供加深了解，故而笔者转向寻求 Hugo 文档 的帮助，最终做到了使用 Github Actions 自动化部署 Hugo 博客。\n准备工作 首先，我们需要创建可以用于部署 Hugo 博客的 Github 仓库，具体的操作可以参考 GitHub Pages 文档 。\n其次，我们需要在电脑上安装 Git 和 Hugo（注意：在 Linux，特别是 Ubuntu 上，请不要使用默认的包管理器安装 Hugo，此法安装的 Hugo 版本有时过低，会造成大量错误），请参考 此文档 进行安装。\n之后，我们将使用 Hugo 在本地创建网站，名称建议使用 username.github.io（其中 username 是你的 Github ID），具体的方法请参照 此文档。\nGithub Actions 在完成准备工作后，我们需要在本地创建网站的文件夹中建立 .github/workflows/gh-pages.yml 文件，在其中填入（此代码参考 Hugo 文档中 Host on GitHub 一项）：\nname: github pages on: push: branches: - main  # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 之后推送至 Github，并将仓库中 Settings - Pages - Source - Branch 的设置从 main 修改至 gh-pages 并点击 Save 按钮，即可完成 Github Actions 部署工作。\n","permalink":"http://xqm32.github.io/posts/deploy-hugo-via-github-actions/","summary":"使用 Github Actions 自动化部署 Hugo 博客 笔者一直想有个属于自己的博客，通过在网上不断搜索，笔者发现使用 Hugo 部署至 Github Pages 上是一个不错的选择。但是，这样的部署也有一个缺陷：需要手动生成部署文件，再上传至 Github，这是十分麻烦的。因此笔者又在网上搜索文档、文章，后来了解到，可以使用 Github Actions 进行自动化部署，我们只需要将网站源码推送至 Github 便可以自动化地生成博客网站。不过，虽然在操作上是方便了许多，但如何配置这样的自动化部署似乎依旧是一个复杂的问题。于是笔者继续在网上搜索文档和文章，但大部分都没有给出较为「官方」的解决方案，也很少有参考资料可供加深了解，故而笔者转向寻求 Hugo 文档 的帮助，最终做到了使用 Github Actions 自动化部署 Hugo 博客。\n准备工作 首先，我们需要创建可以用于部署 Hugo 博客的 Github 仓库，具体的操作可以参考 GitHub Pages 文档 。\n其次，我们需要在电脑上安装 Git 和 Hugo（注意：在 Linux，特别是 Ubuntu 上，请不要使用默认的包管理器安装 Hugo，此法安装的 Hugo 版本有时过低，会造成大量错误），请参考 此文档 进行安装。\n之后，我们将使用 Hugo 在本地创建网站，名称建议使用 username.github.io（其中 username 是你的 Github ID），具体的方法请参照 此文档。\nGithub Actions 在完成准备工作后，我们需要在本地创建网站的文件夹中建立 .github/workflows/gh-pages.yml 文件，在其中填入（此代码参考 Hugo 文档中 Host on GitHub 一项）：\nname: github pages on: push: branches: - main  # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.","title":"使用 Github Actions 自动化部署 Hugo 博客"}]