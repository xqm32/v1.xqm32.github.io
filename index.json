[{"content":"本教程基于 在 Windows 10 上安装 WSL 和 开始使用 WSL VS Code 编写，笔者不保证内容的准确性。如有任何疑问，请参考微软有关 WSL 的官方文档。\n启用 WSL（适用于 Linux 的 Windows 子系统） 以管理员身份打开 Powershell（可以右击 Windows 徽标键，并选择该项）并运行如下命令：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 如果想要更新到 WSL 2 请转到 更新至 WSL 2 。若希望直接使用 WSL 1 请直接 重新启动 并转到 安装并配置 Linux 发行版。\n更新至 WSL 2 **注意：**若要更新至 WSL 2，请确保 Windows 10 已经达到以下运行要求：\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。 低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手 更新 Windows 版本。  启用虚拟机功能 以管理员身份打开 Powershell 并运行如下命令：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\nWSL 2 的后续步骤 请参考 后续步骤 来完成，后转 安装并配置 Linux 发行版。\n安装并配置 Linux 发行版 打开 Microsoft Store，安装一个 Linux 发行版，并打开此发行版，后按找提示进行操作即可。\n更改 WSL 的镜像源 使用默认的源下载软件是较为缓慢的，因而我们需要更换更快速的镜像。在国内，我们常用的是 清华大学 和 中国科学技术大学 的镜像。请确认 WSL 的发行版，根据需求选择要使用的镜像：\n 清华大学开源软件镜像站 USTC Open Source Software Mirror  在 WSL 上安装 C/C++ 的编译器 以 Ubuntu 为例，使用如下命令安装：\nsudo apt-get install gcc g++ **注意：**在安装之前，可能需要进行包的更新，可使用如下命令更新：\nsudo apt-get update sudo apt-get upgrade 对于其他 Linux 发行版，请自行在网络上搜索安装与更新的命令，这里不再赘述。\n将 WSL 与 VS Code 一并使用 以下内容参考 开始使用 WSL VS Code，笔者不确保内容的准确性。如有疑问请参考原文。\n安装并配置 VS Code 访问 VS Code 安装页 选择适合的安装程序。\n打开 VS Code，点击拓展并搜索 「WSL」，安装 WSL 远程拓展包，即可完成操作。在中文环境下，我们还可以安装 VS Code 推荐的中文语言包，以方便阅读。\n对于 C/C++，我们可以在拓展中搜索 C++，以安装其有关拓展（包含了语法高亮、调试等功能）。\n更多的 WSL 与 VS Code 共同使用的小技巧的注意事项，请参考 开始使用 WSL VS Code\n","permalink":"http://xqm32.github.io/posts/wsl-vscode-for-c-cpp/","summary":"本教程基于 在 Windows 10 上安装 WSL 和 开始使用 WSL VS Code 编写，笔者不保证内容的准确性。如有任何疑问，请参考微软有关 WSL 的官方文档。\n启用 WSL（适用于 Linux 的 Windows 子系统） 以管理员身份打开 Powershell（可以右击 Windows 徽标键，并选择该项）并运行如下命令：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 如果想要更新到 WSL 2 请转到 更新至 WSL 2 。若希望直接使用 WSL 1 请直接 重新启动 并转到 安装并配置 Linux 发行版。\n更新至 WSL 2 **注意：**若要更新至 WSL 2，请确保 Windows 10 已经达到以下运行要求：\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。 低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手 更新 Windows 版本。  启用虚拟机功能 以管理员身份打开 Powershell 并运行如下命令：","title":"使用 WSL 和 VS Code 配置 C/C++ 开发环境"},{"content":"搬运一篇笔者在知乎发的文章：C 语言实现字符串切片\n基于 Python 的切片的格式实现的 C 语言字符串切片：\n#include \u0026lt;ctype.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef long long SizeType; size_t fgetln(FILE* stream, char* dest, size_t size) { size_t i; for (i = 0, *dest = fgetc(stream); *dest != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; !feof(stream) \u0026amp;\u0026amp; --size \u0026gt; 0; ++i, *++dest = fgetc(stream)) ; *dest = \u0026#39;\\0\u0026#39;; return i; } // 读取一行字符串。  size_t slice(char* from, char* to, SizeType begin, SizeType end, SizeType interval) { SizeType i; begin += begin \u0026lt; 0 ? strlen(from) : 0; end += end \u0026gt; 0 ? 0 : strlen(from); interval = interval ? interval : 1; for (i = 0; from[begin] != \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; begin \u0026lt; end; ++i, begin += interval) to[i] = from[begin]; to[i] = \u0026#39;\\0\u0026#39;; return i; } // 切片函数。  char* StrSize(char* from, SizeType* m, SizeType* n, SizeType* o) { *m = atoll(from); from = strchr(from, \u0026#39;:\u0026#39;); if (!from) return from; *n = atoll(++from); from = strchr(from, \u0026#39;:\u0026#39;); if (!from) return from; *o = atoll(++from); return from; } // 字符串解析成数字，由 \u0026#34;:\u0026#34; 分隔。  size_t strslice(char* format, char* from, char* to) { SizeType m = 0, n = 0, o = 0; StrSize(format, \u0026amp;m, \u0026amp;n, \u0026amp;o); // printf(\u0026#34;%lld, %lld, %lld\\n\u0026#34;, m, n, o);  return slice(from, to, m, n, o); } // 用字符串作为切片的格式的切片函数。  int main(int argc, char* argv[]) { char* String = malloc(128); char* Format = malloc(128); char* Save = malloc(128); for (;;) { memset(String, 0, 128); memset(Format, 0, 128); memset(Save, 0, 128); fgetln(stdin, String, 128); fgetln(stdin, Format, 128); strslice(Format, String, Save); printf(\u0026#34;%s\\n\u0026#34;, Save); } } 测试：\nHello world :: Hello world Hello world 1 ello world Hello world -1 d Hello world 1: ello world Hello world -1: d Hello world :1 H Hello world :-1 Hello worl Hello world ::1 Hello world Hello world ::2 Hlowrd Hello world 1:-1 ello worl Hello world 2:1 [无输出] Hello world -2:-1 l Hello world -1:-2 [无输出] ","permalink":"http://xqm32.github.io/posts/slicing-string-in-c-language/","summary":"搬运一篇笔者在知乎发的文章：C 语言实现字符串切片\n基于 Python 的切片的格式实现的 C 语言字符串切片：\n#include \u0026lt;ctype.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef long long SizeType; size_t fgetln(FILE* stream, char* dest, size_t size) { size_t i; for (i = 0, *dest = fgetc(stream); *dest != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; !feof(stream) \u0026amp;\u0026amp; --size \u0026gt; 0; ++i, *++dest = fgetc(stream)) ; *dest = \u0026#39;\\0\u0026#39;; return i; } // 读取一行字符串。  size_t slice(char* from, char* to, SizeType begin, SizeType end, SizeType interval) { SizeType i; begin += begin \u0026lt; 0 ?","title":"C 语言实现字符串切片"},{"content":"笔者一直想有个属于自己的博客，通过在网上不断搜索，笔者发现使用 Hugo 部署至 Github Pages 上是一个不错的选择。但是，这样的部署也有一个缺陷：需要手动生成部署文件，再上传至 Github，这是十分麻烦的。因此笔者又在网上搜索文档、文章，后来了解到，可以使用 Github Actions 进行自动化部署，我们只需要将网站源码推送至 Github 便可以自动化地生成博客网站。不过，虽然在操作上是方便了许多，但如何配置这样的自动化部署似乎依旧是一个复杂的问题。于是笔者继续在网上搜索文档和文章，但大部分都没有给出较为「官方」的解决方案，也很少有参考资料可供加深了解，故而笔者转向寻求 Hugo 文档 的帮助，最终做到了使用 Github Actions 自动化部署 Hugo 博客。\n准备工作 首先，我们需要创建可以用于部署 Hugo 博客的 Github 仓库，具体的操作可以参考 GitHub Pages 文档 。\n其次，我们需要在电脑上安装 Git 和 Hugo（注意：在 Linux，特别是 Ubuntu 上，请不要使用默认的包管理器安装 Hugo，此法安装的 Hugo 版本有时过低，会造成大量错误），请参考 此文档 进行安装。\n之后，我们将使用 Hugo 在本地创建网站，名称建议使用 username.github.io（其中 username 是你的 Github ID），具体的方法请参照 此文档。\nGithub Actions 在完成准备工作后，我们需要在本地创建网站的文件夹中建立 .github/workflows/gh-pages.yml 文件，在其中填入（此代码参考 Hugo 文档中 Host on GitHub 一项）：\nname: github pages on: push: branches: - main  # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 之后推送至 Github，并将仓库中 Settings - Pages - Source - Branch 的设置从 main 修改至 gh-pages 并点击 Save 按钮，即可完成 Github Actions 部署工作。\n","permalink":"http://xqm32.github.io/posts/deploy-hugo-via-github-actions/","summary":"笔者一直想有个属于自己的博客，通过在网上不断搜索，笔者发现使用 Hugo 部署至 Github Pages 上是一个不错的选择。但是，这样的部署也有一个缺陷：需要手动生成部署文件，再上传至 Github，这是十分麻烦的。因此笔者又在网上搜索文档、文章，后来了解到，可以使用 Github Actions 进行自动化部署，我们只需要将网站源码推送至 Github 便可以自动化地生成博客网站。不过，虽然在操作上是方便了许多，但如何配置这样的自动化部署似乎依旧是一个复杂的问题。于是笔者继续在网上搜索文档和文章，但大部分都没有给出较为「官方」的解决方案，也很少有参考资料可供加深了解，故而笔者转向寻求 Hugo 文档 的帮助，最终做到了使用 Github Actions 自动化部署 Hugo 博客。\n准备工作 首先，我们需要创建可以用于部署 Hugo 博客的 Github 仓库，具体的操作可以参考 GitHub Pages 文档 。\n其次，我们需要在电脑上安装 Git 和 Hugo（注意：在 Linux，特别是 Ubuntu 上，请不要使用默认的包管理器安装 Hugo，此法安装的 Hugo 版本有时过低，会造成大量错误），请参考 此文档 进行安装。\n之后，我们将使用 Hugo 在本地创建网站，名称建议使用 username.github.io（其中 username 是你的 Github ID），具体的方法请参照 此文档。\nGithub Actions 在完成准备工作后，我们需要在本地创建网站的文件夹中建立 .github/workflows/gh-pages.yml 文件，在其中填入（此代码参考 Hugo 文档中 Host on GitHub 一项）：\nname: github pages on: push: branches: - main  # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.","title":"使用 Github Actions 自动化部署 Hugo 博客"}]