<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>技术分享 on Qiming 的博客</title><link>http://xqm32.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</link><description>Recent content in 技术分享 on Qiming 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 15 Nov 2021 13:15:31 +0800</lastBuildDate><atom:link href="http://xqm32.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 课程知识点总结</title><link>http://xqm32.github.io/posts/java-course-knowledge-points/</link><pubDate>Mon, 15 Nov 2021 13:15:31 +0800</pubDate><guid>http://xqm32.github.io/posts/java-course-knowledge-points/</guid><description>注意：本文是合肥工业大学软件工程专业《Java 语言程序设计》课程的知识点总结，基于课程老师给出的知识点总结，笔者不保证内容的准确性，请谨慎参考。
若文中存在任何问题或有任何疑问请前往 Issue 页面。
概述 Java 发展历史：
① 1990 年代初由 Sun 公司开发，最初被命名为 Oak，用于家用电器；
② 1995 年，Sun 改造了 Oak，以 Java 的名称正式发布，广泛应用于互联网。
J2ME、J2SE、J2EE：
J2ME：Java 2 Platform, Micro Edition，应用于嵌入式（embedded）及移动设备（mobile device）；
J2SE：Java 2 Platform, Standard Edition，应用于桌面（desktop）及服务器（server）环境；
J2EE：Java 2 Platform, Enterprise Edition，应用于分布式计算（distributed computing）及网络服务（web services），是 J2SE 的拓展。
Java 语言的特点：
开放、简单、健壮、安全、面向网络、完全的面向对象编程（OOP）、跨平台（WORA）；
WORA：Write One, Run Anywhere
Java 与 C++ 的比较：
① Java 无指针；
② Java 无结构体和联合体；
③ Java 无运算符重载；</description></item><item><title>使用 WSL 和 VS Code 配置 C/C++ 开发环境</title><link>http://xqm32.github.io/posts/wsl-vscode-for-c-cpp/</link><pubDate>Tue, 14 Sep 2021 18:46:17 +0800</pubDate><guid>http://xqm32.github.io/posts/wsl-vscode-for-c-cpp/</guid><description>本教程基于 在 Windows 10 上安装 WSL 和 开始使用 WSL VS Code 编写，笔者不保证内容的准确性。如有任何疑问，请参考微软有关 WSL 的官方文档。
启用 WSL（适用于 Linux 的 Windows 子系统） 以管理员身份打开 Powershell（可以右击 Windows 徽标键，并选择该项）并运行如下命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 如果想要更新到 WSL 2 请转到 更新至 WSL 2 。若希望直接使用 WSL 1 请直接 重新启动 并转到 安装并配置 Linux 发行版。
更新至 WSL 2 注意：若要更新至 WSL 2，请确保 Windows 10 已经达到以下运行要求：
对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。 低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手 更新 Windows 版本。 启用虚拟机功能 以管理员身份打开 Powershell 并运行如下命令：</description></item><item><title>使用 Github Actions 自动化部署 Hugo 博客</title><link>http://xqm32.github.io/posts/deploy-hugo-via-github-actions/</link><pubDate>Sat, 04 Sep 2021 19:47:57 +0800</pubDate><guid>http://xqm32.github.io/posts/deploy-hugo-via-github-actions/</guid><description>笔者一直想有个属于自己的博客，通过在网上不断搜索，笔者发现使用 Hugo 部署至 Github Pages 上是一个不错的选择。但是，这样的部署也有一个缺陷：需要手动生成部署文件，再上传至 Github，这是十分麻烦的。因此笔者又在网上搜索文档、文章，后来了解到，可以使用 Github Actions 进行自动化部署，我们只需要将网站源码推送至 Github 便可以自动化地生成博客网站。不过，虽然在操作上是方便了许多，但如何配置这样的自动化部署似乎依旧是一个复杂的问题。于是笔者继续在网上搜索文档和文章，但大部分都没有给出较为「官方」的解决方案，也很少有参考资料可供加深了解，故而笔者转向寻求 Hugo 文档 的帮助，最终做到了使用 Github Actions 自动化部署 Hugo 博客。
准备工作 首先，我们需要创建可以用于部署 Hugo 博客的 Github 仓库，具体的操作可以参考 GitHub Pages 文档 。
其次，我们需要在电脑上安装 Git 和 Hugo（注意：在 Linux，特别是 Ubuntu 上，请不要使用默认的包管理器安装 Hugo，此法安装的 Hugo 版本有时过低，会造成大量错误），请参考 此文档 进行安装。
之后，我们将使用 Hugo 在本地创建网站，名称建议使用 username.github.io（其中 username 是你的 Github ID），具体的方法请参照 此文档。
Github Actions 在完成准备工作后，我们需要在本地创建网站的文件夹中建立 .github/workflows/gh-pages.yml 文件，在其中填入（此代码参考 Hugo 文档中 Host on GitHub 一项）：
name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.</description></item><item><title>C 语言实现字符串切片</title><link>http://xqm32.github.io/posts/slicing-string-in-c-language/</link><pubDate>Sat, 04 Sep 2021 16:35:51 +0800</pubDate><guid>http://xqm32.github.io/posts/slicing-string-in-c-language/</guid><description>搬运一篇笔者在知乎发的文章：C 语言实现字符串切片
基于 Python 的切片的格式实现的 C 语言字符串切片：
#include &amp;lt;ctype.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; typedef long long SizeType; size_t fgetln(FILE* stream, char* dest, size_t size) { size_t i; for (i = 0, *dest = fgetc(stream); *dest != &amp;#39;\n&amp;#39; &amp;amp;&amp;amp; !feof(stream) &amp;amp;&amp;amp; --size &amp;gt; 0; ++i, *++dest = fgetc(stream)) ; *dest = &amp;#39;\0&amp;#39;; return i; } // 读取一行字符串。 size_t slice(char* from, char* to, SizeType begin, SizeType end, SizeType interval) { SizeType i; begin += begin &amp;lt; 0 ?</description></item></channel></rss>